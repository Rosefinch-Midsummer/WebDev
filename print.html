<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Web Development</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="前言.html"><strong aria-hidden="true">1.</strong> 前言</a></li><li class="chapter-item expanded affix "><li class="part-title">Frontend</li><li class="chapter-item expanded "><a href="ES6新特性.html"><strong aria-hidden="true">2.</strong> ES6新特性</a></li><li class="chapter-item expanded "><a href="Vue3入门.html"><strong aria-hidden="true">3.</strong> Vue3入门</a></li><li class="chapter-item expanded "><a href="Vue-Router速成.html"><strong aria-hidden="true">4.</strong> Vue-Router速成</a></li><li class="chapter-item expanded "><a href="Axios速成.html"><strong aria-hidden="true">5.</strong> Axois速成</a></li><li class="chapter-item expanded "><a href="Pinia入门.html"><strong aria-hidden="true">6.</strong> Pinia入门</a></li><li class="chapter-item expanded affix "><li class="part-title">UI Design</li><li class="chapter-item expanded "><a href="AntDesignVue入门.html"><strong aria-hidden="true">7.</strong> AntDesignVue入门</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Web Development</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<p>这里主要记录<code>Web Development</code>相关内容。</p>
<h1 id="脚手架"><a class="header" href="#脚手架">脚手架</a></h1>
<pre><code>npm create vite  # 选择使用 create-vue 自定义项目
npm create vue@latest  # 直接使用create-vue 创建项目
vue-cli #已经过时
</code></pre>
<h1 id="npm"><a class="header" href="#npm">npm</a></h1>
<p>npm 是 nodejs 中进行 <strong>包管理</strong> 的工具；</p>
<p>下载：<a href="https://nodejs.org/en">https://nodejs.org/en</a></p>
<h2 id="21-环境"><a class="header" href="#21-环境">2.1. 环境</a></h2>
<ul>
<li>安装<code>Node.js</code></li>
<li>配置 npm</li>
</ul>
<pre><code>npm config set registry https://registry.npmmirror.com  #设置国内阿里云镜像源
npm config get registry  #查看镜像源
</code></pre>
<h2 id="22-命令"><a class="header" href="#22-命令">2.2. 命令</a></h2>
<ul>
<li>
<p>npm init： 项目初始化；</p>
</li>
<li>
<p>npm init -y：默认一路yes，不用挨个输入信息</p>
</li>
<li>
<p>npm install 包名：安装js包到项目中（仅当前项目有效）。指定 <strong>包名</strong>，或者 <strong>包名@版本号</strong></p>
</li>
<li>
<p>npm install -g： 全局安装，所有都能用</p>
</li>
<li>
<p>可以去 <a href="https://www.npmjs.com/">npm仓库</a> 搜索第三方库</p>
</li>
<li>
<p>npm update 包名：升级包到最新版本</p>
</li>
<li>
<p>npm uninstall 包名：卸载包</p>
</li>
<li>
<p>npm run：项目运行</p>
</li>
</ul>
<h2 id="23-使用流程"><a class="header" href="#23-使用流程">2.3. 使用流程</a></h2>
<p>Java：</p>
<ul>
<li>项目创建：Java环境 -&gt; maven 初始化 -&gt; 添加依赖 -&gt;运行项目</li>
<li>项目迁移：Java环境 -&gt;maven 下载依赖  -&gt;运行项目</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1613913/1712110492836-0f787e3a-4b9c-4236-8250-3912df233a20.png" alt="" /></p>
<h1 id="3-vite"><a class="header" href="#3-vite">3. Vite</a></h1>
<h2 id="31-简介"><a class="header" href="#31-简介">3.1. 简介</a></h2>
<p>中文官网： https://cn.vitejs.dev</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1613913/1708417742836-01ade940-3edf-46df-98f5-a77a8ca6247e.png" alt="" /></p>
<ul>
<li>快速创建前端项目脚手架</li>
<li>统一的工程化规范：目录结构、代码规范、git提交规范等</li>
<li>自动化构建和部署：前端脚手架可以自动进行代码打包、压缩、合并、编译等常见的构建工作，可以通过集成自动化部署脚本，自动将代码部署到测试、生产环境等；</li>
</ul>
<h2 id="32-实战"><a class="header" href="#32-实战">3.2. 实战</a></h2>
<h3 id="321-创建项目"><a class="header" href="#321-创建项目">3.2.1. 创建项目</a></h3>
<pre><code>npm create vite #根据向导选择技术栈
</code></pre>
<h3 id="322-安装依赖"><a class="header" href="#322-安装依赖">3.2.2. 安装依赖</a></h3>
<pre><code>npm install #安装项目所有依赖

npm install axios #安装指定依赖到当前项目
npm install -g xxx # 全局安装
</code></pre>
<h3 id="323-项目启动"><a class="header" href="#323-项目启动">3.2.3. 项目启动</a></h3>
<pre><code>npm run dev #启动项目
</code></pre>
<h3 id="324-项目打包"><a class="header" href="#324-项目打包">3.2.4. 项目打包</a></h3>
<pre><code>npm run build #构建后 生成 dist 文件夹
</code></pre>
<h3 id="325-项目部署"><a class="header" href="#325-项目部署">3.2.5. 项目部署</a></h3>
<ul>
<li>前后分离方式：需要把 dist 文件夹内容部署到如 nginx 之类的服务器上。</li>
<li>前后不分离方式：把 dist 文件夹内容复制到 SpringBoot 项目 <code>resources</code> 下面</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="es6-新特性"><a class="header" href="#es6-新特性">ES6 新特性</a></h1>
<ul>
<li><a href="ES6%E6%96%B0%E7%89%B9%E6%80%A7.html#%E4%BD%95%E8%B0%93-es6-">何谓 ES6 ？</a></li>
<li><a href="ES6%E6%96%B0%E7%89%B9%E6%80%A7.html#11-let--vs-var">1.1 let  VS var</a>
<ul>
<li><a href="ES6%E6%96%B0%E7%89%B9%E6%80%A7.html#111-%E8%B6%8A%E5%9F%9F">1.1.1 越域</a></li>
<li><a href="ES6%E6%96%B0%E7%89%B9%E6%80%A7.html#112-%E9%87%8D%E5%A4%8D%E5%A3%B0%E6%98%8E">1.1.2 重复声明</a></li>
<li><a href="ES6%E6%96%B0%E7%89%B9%E6%80%A7.html#113-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87">1.1.3 变量提升</a></li>
</ul>
</li>
<li><a href="ES6%E6%96%B0%E7%89%B9%E6%80%A7.html#12-const">1.2 const</a></li>
<li><a href="ES6%E6%96%B0%E7%89%B9%E6%80%A7.html#13-%E8%A7%A3%E6%9E%84">1.3 解构</a>
<ul>
<li><a href="ES6%E6%96%B0%E7%89%B9%E6%80%A7.html#131-%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84">1.3.1 数组解构</a></li>
<li><a href="ES6%E6%96%B0%E7%89%B9%E6%80%A7.html#132-%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84">1.3.2 对象解构</a></li>
</ul>
</li>
<li><a href="ES6%E6%96%B0%E7%89%B9%E6%80%A7.html#14-%E9%93%BE%E5%88%A4%E6%96%AD">1.4 链判断</a></li>
<li><a href="ES6%E6%96%B0%E7%89%B9%E6%80%A7.html#15-%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC">1.5 参数默认值</a></li>
<li><a href="ES6%E6%96%B0%E7%89%B9%E6%80%A7.html#16-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">1.6 箭头函数</a></li>
<li><a href="ES6%E6%96%B0%E7%89%B9%E6%80%A7.html#17-%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2">1.7 模板字符串</a></li>
<li><a href="ES6%E6%96%B0%E7%89%B9%E6%80%A7.html#18-promise">1.8 Promise</a>
<ul>
<li><a href="ES6%E6%96%B0%E7%89%B9%E6%80%A7.html#181-fetch-api">1.8.1 fetch api</a></li>
<li><a href="ES6%E6%96%B0%E7%89%B9%E6%80%A7.html#182-promise-%E7%8A%B6%E6%80%81">1.8.2 Promise 状态</a></li>
<li><a href="ES6%E6%96%B0%E7%89%B9%E6%80%A7.html#183promise-%E5%AF%B9%E8%B1%A1">1.8.3Promise 对象</a></li>
</ul>
</li>
<li><a href="ES6%E6%96%B0%E7%89%B9%E6%80%A7.html#19async-%E5%87%BD%E6%95%B0">1.9Async 函数</a></li>
<li><a href="ES6%E6%96%B0%E7%89%B9%E6%80%A7.html#110-%E6%A8%A1%E5%9D%97%E5%8C%96">1.10 模块化</a></li>
</ul>
<h2 id="何谓-es6-"><a class="header" href="#何谓-es6-">何谓 ES6 ？</a></h2>
<ul>
<li>ECMAScript（ES） 是规范、 JavaScript 是 ES 的实现</li>
<li>ES6 的第一个版本 在 2015 年 6 月发布，正式名称是《ECMAScript 2015 标准》（简称 ES2015）</li>
<li>ES6 指是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等</li>
</ul>
<h2 id="11-let--vs-var"><a class="header" href="#11-let--vs-var">1.1 let  VS var</a></h2>
<p>使用 let 可以避免变量提升、变量污染、变量重复声明和临时死区等问题，推荐在 ES6 标准中使用 let 声明变量。</p>
<p>和 let 相比，var 存在诸多问题，比如：</p>
<h3 id="111-越域"><a class="header" href="#111-越域">1.1.1 越域</a></h3>
<p>变量作用域：使用 let 声明的变量具有块级作用域，在 {} 内部声明的变量对外不可见，而使用 var 声明的变量具有函数级作用域，会被提升到函数的顶部。这样可以减少变量的污染和包围性问题。</p>
<pre><code class="language-js">{
  var a = 1;
  let b = 1;
}
console.log (a) // 输出 1
console.log (b) // 报错 Uncaught ReferenceError: b is not defined
</code></pre>
<h3 id="112-重复声明"><a class="header" href="#112-重复声明">1.1.2 重复声明</a></h3>
<p>变量重复声明：使用 let 声明的变量不允许重复声明，而使用 var 声明的变量可以在同一作用域内重复声明，会覆盖前面的声明。</p>
<pre><code class="language-javascript">// 使用 let 声明变量
let x = 10;
let x = 20; // SyntaxError: Identifier 'x' has already been declared

// 使用 var 声明变量
var x = 10;
var x = 20; // 没有错误，x 被重新赋值为 20
</code></pre>
<h3 id="113-变量提升"><a class="header" href="#113-变量提升">1.1.3 变量提升</a></h3>
<p>临时死区：使用 let 声明的变量存在临时死区（temporal dead zone），在声明之前使用变量会报错，而使用 var 则不存在这种情况。</p>
<pre><code class="language-javascript">// 使用 let 声明变量
console.log (x); // ReferenceError: Cannot access 'x' before initialization
let x = 10;

// 使用 var 声明变量
console.log (x); // 输出 undefined
var x = 10;
</code></pre>
<h2 id="12-const"><a class="header" href="#12-const">1.2 const</a></h2>
<pre><code class="language-js">// 1. 声明之后不允许改变
// 2. 一但声明必须初始化，否则会报错
const a = 1;
a = 3; //Uncaught TypeError: Assignment to constant variable.
</code></pre>
<h2 id="13-解构"><a class="header" href="#13-解构">1.3 解构</a></h2>
<h3 id="131-数组解构"><a class="header" href="#131-数组解构">1.3.1 数组解构</a></h3>
<pre><code class="language-js">let arr = [1, 2, 3];
// 以前我们想获取其中的值，只能通过角标。ES6 可以这样：
const [x, y, z] = arr;//x，y，z 将与 arr 中的每个位置对应来取值
// 然后打印
console.log (x, y, z);
</code></pre>
<h3 id="132-对象解构"><a class="header" href="#132-对象解构">1.3.2 对象解构</a></h3>
<pre><code class="language-js">const person = {
    name: "jack",
    age: 21,
    language: ['java', 'js', 'css']
}
// 解构表达式获取值，将 person 里面每一个属性和左边对应赋值
const {name, age, language} = person;
// 等价于下面
//const name = person.name;
//const age = person.age;
//const language = person.language;
// 可以分别打印
console.log (name);
console.log (age);
console.log (language);
</code></pre>
<p>// 扩展：如果想要将 name 的值赋值给其他变量，可以如下，nn 是新的变量名</p>
<pre><code class="language-js">const person = {
    name: "jack",
    age: 21,
    language: ['java', 'js', 'css']
}
const {name: nn, age, language} = person;
console.log (nn);
console.log (age);
console.log (language);
</code></pre>
<h2 id="14-链判断"><a class="header" href="#14-链判断">1.4 链判断</a></h2>
<p>如果读取对象内部的某个属性，往往需要判断一下，属性的上层对象是否存在。<br />
比如，读取 <code>message.body.user.firstName</code> 这个属性，安全的写法是写成下面这样。</p>
<pre><code class="language-js">let  message = null;
// 错误的写法
const  firstName = message.body.user.firstName || 'default';

// 正确的写法
const firstName = (message
                   &amp;&amp; message.body
                   &amp;&amp; message.body.user
                   &amp;&amp; message.body.user.firstName) || 'default';
console.log (firstName)
</code></pre>
<p>这样的层层判断非常麻烦，因此 <a href="https://github.com/tc39/proposal-optional-chaining">ES2020</a> 引入了 “链判断运算符”（optional chaining operator）?.，简化上面的写法。</p>
<pre><code class="language-js">let message = null;
const firstName = message?.body?.user?.firstName || 'default';
console.log (firstName);
</code></pre>
<h2 id="15-参数默认值"><a class="header" href="#15-参数默认值">1.5 参数默认值</a></h2>
<pre><code class="language-js">// 在 ES6 以前，我们无法给一个函数参数设置默认值，只能采用变通写法：
function add (a, b) {
  // 判断 b 是否为空，为空就给默认值 1
  b = b || 1;
  return a + b;
}
// 传一个参数
console.log (add (10));

// 现在可以这么写：直接给参数写上默认值，没传就会自动使用默认值
function add2 (a, b = 1) {
  return a + b;
}

// 传一个参数
console.log (add2 (10));
</code></pre>
<h2 id="16-箭头函数"><a class="header" href="#16-箭头函数">1.6 箭头函数</a></h2>
<p>以前声明一个方法：</p>
<pre><code class="language-js">var print = function (obj) {
  console.log (obj);
}
</code></pre>
<p>现在可以简写为：</p>
<pre><code class="language-js">
let print = obj =&gt; console.log (obj);
// 测试调用
print (100);
</code></pre>
<p>两个参数的情况：</p>
<pre><code class="language-js">let sum = function (a, b) {
    return a + b;
}
// 简写为：
// 当只有一行语句，并且需要返回结果时，可以省略 {} , 结果会自动返回。
let sum2 = (a, b) =&gt; a + b;
// 测试调用
console.log (sum2 (10, 10));//20
// 代码不止一行，可以用 `{}` 括起来
let sum3 = (a, b) =&gt; {
    c = a + b;
    return c;
};
// 测试调用
console.log (sum3 (10, 20));//30
</code></pre>
<h2 id="17-模板字符串"><a class="header" href="#17-模板字符串">1.7 模板字符串</a></h2>
<p>以前的写法：</p>
<pre><code class="language-js">let name = "张三";
    let person = {
      age: 25,
      email: "123@qq.com"
    }
    const { age, email } = person;
    let info = "你好，我的名字是：【" + name + "】，年龄是：【" + age + "】，邮箱是：【" + email + "】"
    console.log (info);
</code></pre>
<p>模板字符串的写法：</p>
<pre><code class="language-js">let name = "张三";
    let person = {
      age: 25,
      email: "123@qq.com"
    }
    let info = `你好，我的名字是：${name}，年龄是：${person.age}，邮箱是：${person.email}`
    console.log (info);
</code></pre>
<h2 id="18-promise"><a class="header" href="#18-promise">1.8 Promise</a></h2>
<p>代表 异步对象，类似 <code>Java</code> 中的 <code>CompletableFuture</code></p>
<p>Promise 是现代 JavaScript 中异步编程的基础，是一个由异步函数返回的可以向我们指示当前操作所处的状态的对象。在 Promise 返回给调用者的时候，操作往往还没有完成，但 Promise 对象可以让我们操作最终完成时对其进行处理（无论成功还是失败）  。</p>
<h3 id="181-fetch-api"><a class="header" href="#181-fetch-api">1.8.1 fetch api</a></h3>
<p>fetch 是浏览器支持从远程获取数据的一个函数，这个函数返回的就是 Promise 对象  。使用示例：</p>
<pre><code class="language-js">const fetchPromise = fetch (
  "https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json"
);

console.log (fetchPromise);

fetchPromise.then ((response) =&gt; {
  console.log (`已收到响应：${response.status}`);
});

console.log ("已发送请求……");
</code></pre>
<p>通过 fetch () API 得到一个 Response 对象：</p>
<ul>
<li>response.status： 读取响应状态码</li>
<li>response.json ()：读取响应体 json 数据（这也是个异步对象）；</li>
</ul>
<p>使用示例：</p>
<pre><code class="language-js">const fetchPromise = fetch (
  "https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json",
);

fetchPromise.then ((response) =&gt; {
  const jsonPromise = response.json ();
  jsonPromise.then ((json) =&gt; {
	console.log (json [0].name);
  });
});
</code></pre>
<h3 id="182-promise-状态"><a class="header" href="#182-promise-状态">1.8.2 Promise 状态</a></h3>
<p>首先，Promise 有三种状态：</p>
<ul>
<li>待定（pending）：初始状态，既没有被兑现，也没有被拒绝。这是调用 fetch () 返回 Promise 时的状态，此时请求还在进行中。</li>
<li>已兑现（fulfilled）：意味着操作成功完成。当 Promise 完成时，它的 then () 处理函数被调用。</li>
<li>已拒绝（rejected）：意味着操作失败。当一个 Promise 失败时，它的 catch () 处理函数被调用。</li>
</ul>
<h3 id="183promise-对象"><a class="header" href="#183promise-对象">1.8.3Promise 对象</a></h3>
<p>代码模板：</p>
<pre><code class="language-js">const promise = new Promise ((resolve, reject) =&gt; {
// 执行异步操作
if (/* 异步操作成功 */) {
      resolve (value);// 调用 resolve，代表 Promise 将返回成功的结果
    } else {
      reject (error);// 调用 reject，代表 Promise 会返回失败结果
    }
});
</code></pre>
<p>ES6 之前写法示例：</p>
<pre><code class="language-js">let get = function (url, data) {
	return new Promise ((resolve, reject) =&gt; {
		$.ajax ({
			url: url,
			type: "GET",
			data: data,
			success (result) {
				resolve (result);
			},
			error (error) {
				reject (error);
			}
		});
	})
}
</code></pre>
<h2 id="19async-函数"><a class="header" href="#19async-函数">1.9Async 函数</a></h2>
<p>async function 声明创建一个绑定到给定名称的新异步函数。函数体内允许使用 await 关键字，这使得我们可以更简洁地编写基于 promise 的异步代码，并且避免了显式地配置 promise 链的需要。</p>
<p>async 函数是使用 async 关键字声明的函数。async 函数是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction">AsyncFunction</a> 构造函数的实例，并且其中允许使用 await 关键字。</p>
<p>async 和 await 关键字让我们可以用一种更简洁的方式写出基于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> 的异步行为，而无需刻意地链式调用 promise。</p>
<p>async 函数 返回的还是 Promise 对象 。</p>
<p>代码模板如下所示：</p>
<pre><code class="language-js">async function myFunction () {
  // 这是一个异步函数

}
</code></pre>
<p>在异步函数中，你可以在调用一个返回 Promise 的函数之前使用 await 关键字。这使得代码在该点上等待，直到 Promise 被完成，这时 Promise 的响应被当作返回值，或者被拒绝的响应被作为错误抛出。</p>
<p>使用示例：</p>
<pre><code class="language-js">async function fetchProducts () {
  try {
    // 在这一行之后，我们的函数将等待 `fetch ()` 调用完成
    // 调用 `fetch ()` 将返回一个 “响应” 或抛出一个错误
    const response = await fetch (
      "https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json",
    );
    if (!response.ok) {
      throw new Error (`HTTP 请求错误：${response.status}`);
    }
    // 在这一行之后，我们的函数将等待 `response.json ()` 的调用完成
    // `response.json ()` 调用将返回 JSON 对象或抛出一个错误
    const json = await response.json ();
    console.log (json [0].name);
  } catch (error) {
    console.error (`无法获取产品列表：${error}`);
  }
}

fetchProducts ();
</code></pre>
<h2 id="110-模块化"><a class="header" href="#110-模块化">1.10 模块化</a></h2>
<p>将 JavaScript 程序拆分为可按需导入的单独模块的机制。Node.js 已经提供这个能力很长时间了，还有很多的 JavaScript 库和框架已经开始了模块的使用（例如，<a href="https://en.wikipedia.org/wiki/CommonJS">CommonJS</a> 和基于 <a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md">AMD</a> 的其他模块系统 如 <a href="https://requirejs.org/">RequireJS</a>，以及最新的 <a href="https://webpack.github.io/">Webpack</a> 和 <a href="https://babeljs.io/">Babel</a>）。</p>
<p>好消息是，最新的浏览器开始原生支持模块功能了。</p>
<p><code>index.html</code>  内容如下所示：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src="main.js" type="module"/&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 &gt; 模块化测试 &lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>指定脚本类型为 <code>module</code>即可</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="vue3-入门"><a class="header" href="#vue3-入门">Vue3 入门</a></h1>
<ul>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#vite-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">vite 创建项目</a></li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#41-%E7%BB%84%E4%BB%B6%E5%8C%96">4.1. 组件化</a></li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#42-sfc">4.2. SFC</a></li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#43-vue-%E5%B7%A5%E7%A8%8B">4.3. Vue 工程</a>
<ul>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#431-%E5%88%9B%E5%BB%BA--%E8%BF%90%E8%A1%8C">4.3.1. 创建 &amp; 运行</a></li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#432-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86">4.3.2. 运行原理</a></li>
</ul>
</li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-">应用实例 ​</a></li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#%E6%A0%B9%E7%BB%84%E4%BB%B6-">根组件 ​</a></li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#%E6%8C%82%E8%BD%BD%E5%BA%94%E7%94%A8-">挂载应用 ​</a>
<ul>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#dom-%E4%B8%AD%E7%9A%84%E6%A0%B9%E7%BB%84%E4%BB%B6%E6%A8%A1%E6%9D%BF-">DOM 中的根组件模板 ​</a></li>
</ul>
</li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#44-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8">4.4. 基础使用</a>
<ul>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#441-%E6%8F%92%E5%80%BC">4.4.1. 插值</a></li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#442-%E6%8C%87%E4%BB%A4">4.4.2. 指令</a>
<ul>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#4421-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9Av-on">4.4.2.1. 事件绑定：v-on</a></li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#4422-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%ADv-if">4.4.2.2. 条件判断：v-if</a></li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#4423-%E5%BE%AA%E7%8E%AFv-for">4.4.2.3. 循环：v-for</a></li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#4424-%E6%9B%B4%E5%A4%9A%E6%8C%87%E4%BB%A4">4.4.2.4. 更多指令</a></li>
</ul>
</li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#443-%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9A">4.4.3. 属性绑定</a></li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#444-%E5%93%8D%E5%BA%94%E5%BC%8F---ref-">4.4.4. 响应式 - ref ()</a>
<ul>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#4441-%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">4.4.4.1. 使用方式</a></li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#4442-%E6%B7%B1%E5%B1%82%E5%93%8D%E5%BA%94%E6%80%A7">4.4.4.2. 深层响应性</a></li>
</ul>
</li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#445-%E5%93%8D%E5%BA%94%E5%BC%8F---reactive-">4.4.5. 响应式 - reactive ()</a></li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#446-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A">4.4.6. 表单绑定</a></li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#447-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7---computed">4.4.7. 计算属性 - computed</a></li>
</ul>
</li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#45-%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95">4.5. 进阶用法</a>
<ul>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#451-%E7%9B%91%E5%90%AC---watchwatcheffect">4.5.1. 监听 - watch&amp;watchEffect</a></li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#452-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">4.5.2. 生命周期</a></li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#453-%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC">4.5.3. 组件传值</a>
<ul>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#4531-%E7%88%B6%E4%BC%A0%E5%AD%90---props">4.5.3.1. 父传子 - Props</a></li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#4532-%E5%AD%90%E4%BC%A0%E7%88%B6---emit">4.5.3.2. 子传父 - Emit</a></li>
</ul>
</li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#454-%E6%8F%92%E6%A7%BD---slots">4.5.4. 插槽 - Slots</a>
<ul>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#4541-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">4.5.4.1. 基本使用</a></li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#4542-%E9%BB%98%E8%AE%A4%E5%86%85%E5%AE%B9">4.5.4.2. 默认内容</a></li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#4543-%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD">4.5.4.3. 具名插槽</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="Vue3%E5%85%A5%E9%97%A8.html#46-%E6%80%BB%E7%BB%93">4.6. 总结</a></li>
</ul>
<h2 id="vite-创建项目"><a class="header" href="#vite-创建项目">vite 创建项目</a></h2>
<p>我们使用 vite 创建 vue 项目脚手架，并测试 Vue 功能</p>
<pre><code class="language-shell">npm create vite #根据向导选择技术栈
</code></pre>
<h2 id="41-组件化"><a class="header" href="#41-组件化">4.1. 组件化</a></h2>
<p>组件系统是一个抽象的概念；</p>
<ul>
<li>组件：小型、独立、可复用的单元</li>
<li>组合：通过组件之间的组合、包含关系构建出一个完整应用</li>
</ul>
<p>几乎任意类型的应用界面都可以抽象为一个组件树；</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1613913/1708754538888-ced4be1b-71b9-4238-9398-372985b1b99a.png?x-oss-process=image%2Fformat%2Cwebp" alt="" /></p>
<h2 id="42-sfc"><a class="header" href="#42-sfc">4.2. SFC</a></h2>
<p>Vue 的<strong>单文件组件</strong> (即 *.vue 文件，英文 Single-File Component，简称 <strong>SFC</strong>) 是一种特殊的文件格式，使我们能够将一个 Vue 组件的模板、逻辑与样式封装在单个文件中.</p>
<pre><code class="language-vue">&lt;script setup&gt;
  // 编写脚本
&lt;/script&gt;

&lt;template&gt;
  // 编写页面模板
&lt;/template&gt;

&lt;style scoped&gt;
  // 编写样式
&lt;/style&gt;
</code></pre>
<h2 id="43-vue-工程"><a class="header" href="#43-vue-工程">4.3. Vue 工程</a></h2>
<h3 id="431-创建--运行"><a class="header" href="#431-创建--运行">4.3.1. 创建 &amp; 运行</a></h3>
<pre><code>npm create vite  # 按照提示选择 Vue
npm run dev #项目运行命令
</code></pre>
<h3 id="432-运行原理"><a class="header" href="#432-运行原理">4.3.2. 运行原理</a></h3>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1613913/1712477454104-1234f405-1fdf-457c-8b84-a4cae4f4645e.png" alt="" /></p>
<h2 id="应用实例-"><a class="header" href="#应用实例-">应用实例 <a href="https://cn.vuejs.org/guide/essentials/application.html#the-application-instance">​</a></a></h2>
<p>每个 Vue 应用都是通过 <a href="https://cn.vuejs.org/api/application.html#createapp"><code>createApp</code></a> 函数创建一个新的 <strong>应用实例</strong>：</p>
<pre><code class="language-js">import { createApp } from 'vue'

const app = createApp ({
  /* 根组件选项 */
})
</code></pre>
<h2 id="根组件-"><a class="header" href="#根组件-">根组件 <a href="https://cn.vuejs.org/guide/essentials/application.html#the-root-component">​</a></a></h2>
<p>我们传入 <code>createApp</code> 的对象实际上是一个组件，每个应用都需要一个 “根组件”，其他组件将作为其子组件。</p>
<p>如果你使用的是单文件组件，我们可以直接从另一个文件中导入根组件。</p>
<pre><code class="language-js">import { createApp } from 'vue'
// 从一个单文件组件中导入根组件
import App from './App.vue'

const app = createApp (App)
</code></pre>
<p>虽然本指南中的许多示例只需要一个组件，但大多数真实的应用都是由一棵嵌套的、可重用的组件树组成的。例如，一个待办事项 (Todos) 应用的组件树可能是这样的：</p>
<pre><code>App (root component)
├─ TodoList
│  └─ TodoItem
│     ├─ TodoDeleteButton
│     └─ TodoEditButton
└─ TodoFooter
   ├─ TodoClearButton
   └─ TodoStatistics
</code></pre>
<p>我们会在指南的后续章节中讨论如何定义和组合多个组件。在那之前，我们得先关注一个组件内到底发生了什么。</p>
<h2 id="挂载应用-"><a class="header" href="#挂载应用-">挂载应用 <a href="https://cn.vuejs.org/guide/essentials/application.html#mounting-the-app">​</a></a></h2>
<p>应用实例必须在调用了 <code>.mount ()</code> 方法后才会渲染出来。该方法接收一个 “容器” 参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串：</p>
<pre><code class="language-html">&lt;div id="app"&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-js">app.mount ('#app')
</code></pre>
<p>应用根组件的内容将会被渲染在容器元素里面。容器元素自己将<strong>不会</strong>被视为应用的一部分。</p>
<p><code>.mount ()</code> 方法应该始终在整个应用配置和资源注册完成后被调用。同时请注意，不同于其他资源注册方法，它的返回值是根组件实例而非应用实例。</p>
<h3 id="dom-中的根组件模板-"><a class="header" href="#dom-中的根组件模板-">DOM 中的根组件模板 <a href="https://cn.vuejs.org/guide/essentials/application.html#in-dom-root-component-template">​</a></a></h3>
<p>根组件的模板通常是组件本身的一部分，但也可以直接通过在挂载容器内编写模板来单独提供：</p>
<pre><code class="language-html">&lt;div id="app"&gt;
  &lt;button @click="count++"&gt;{{ count }}&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">import { createApp } from 'vue'

const app = createApp ({
  data () {
    return {
      count: 0
    }
  }
})

app.mount ('#app')
</code></pre>
<p>当根组件没有设置 <code>template</code> 选项时，Vue 将自动使用容器的 <code>innerHTML</code> 作为模板。</p>
<p>DOM 内模板通常用于 <a href="https://cn.vuejs.org/guide/quick-start.html#using-vue-from-cdn">无构建步骤</a> 的 Vue 应用程序。它们也可以与服务器端框架一起使用，其中根模板可能是由服务器动态生成的。</p>
<h2 id="44-基础使用"><a class="header" href="#44-基础使用">4.4. 基础使用</a></h2>
<h3 id="441-插值"><a class="header" href="#441-插值">4.4.1. 插值</a></h3>
<pre><code class="language-vue">&lt;script setup&gt;
// 基本数据
let name = "张三"
let age = 18

// 对象数据
let car = {
  brand: "奔驰",
  price: 777
}
&lt;/script&gt;

&lt;template&gt;
  &lt;p&gt; name: {{name}} &lt;/p&gt;
  &lt;p&gt; age: {{age}} &lt;/p&gt;
  &lt;div style="border: 3px solid red"&gt;
    &lt;p &gt; 品牌：{{car.brand}}&lt;/p&gt;
    &lt;p &gt; 价格：{{car.price}}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;

&lt;/style&gt;vue
</code></pre>
<p>注意：没有 setup 则不显示 name 等属性值</p>
<p>在 Vue 3 中，<code>&lt;script setup&gt;</code> 是一种新的语法糖，用于简化组件的编写和逻辑的组织。它可以让开发者在组件中使用函数式组件的形式编写组件逻辑，同时也能让开发者在组件中使用 Composition API 来编写逻辑。</p>
<p>通过 <code>&lt;script setup&gt;</code> 语法，开发者可以将组件中的 props、state 和方法等都放在一个 setup 函数中进行定义，从而避免了显式地在组件中引入这些内容。这样可以使组件更加清晰简洁，并且可以更好地组织和重用逻辑代码。</p>
<p>总的来说，<code>&lt;script setup&gt;</code> 的作用是简化组件的编写和逻辑的组织，让开发者更加方便地使用 Vue 的 Composition API 来编写逻辑。</p>
<h3 id="442-指令"><a class="header" href="#442-指令">4.4.2. 指令</a></h3>
<h4 id="4421-事件绑定v-on"><a class="header" href="#4421-事件绑定v-on">4.4.2.1. 事件绑定：v-on</a></h4>
<p>使用 <code>v-on</code> 指令，可以为元素绑定事件。可以简写为 <code>@</code></p>
<pre><code class="language-vue">&lt;script setup&gt;
// 定义事件回调
function buy (){
  alert ("购买成功");
}
&lt;/script&gt;
&lt;template&gt;
  &lt;button v-on:click="buy"&gt; 购买 &lt;/button&gt;
  &lt;button @click="buy"&gt; 购买 &lt;/button&gt;
&lt;/template&gt;
&lt;style scoped&gt;
&lt;/style&gt;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1613913/1708763498360-bc7a713e-b02a-4b17-abd9-bb1a6371bf50.png" alt="" /></p>
<p>Modifiers：修饰符详情</p>
<p><a href="https://cn.vuejs.org/guide/essentials/event-handling.html">https://cn.vuejs.org/guide/essentials/event-handling.html</a></p>
<h4 id="4422-条件判断v-if"><a class="header" href="#4422-条件判断v-if">4.4.2.2. 条件判断：v-if</a></h4>
<h4 id="4423-循环v-for"><a class="header" href="#4423-循环v-for">4.4.2.3. 循环：v-for</a></h4>
<h4 id="4424-更多指令"><a class="header" href="#4424-更多指令">4.4.2.4. 更多指令</a></h4>
<p><a href="https://cn.vuejs.org/api/built-in-directives.html">https://cn.vuejs.org/api/built-in-directives.html</a>；后期我们都会用到。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1613913/1709712996927-3af836de-8e74-45b9-8757-9fb7972c1963.png" alt="" /></p>
<h3 id="443-属性绑定"><a class="header" href="#443-属性绑定">4.4.3. 属性绑定</a></h3>
<ul>
<li>使用 <code>v-bind: 属性 ='xx'</code> 语法，可以为标签的某个属性绑定值；</li>
<li>可以简写为 <code>: 属性 ='xx'</code></li>
</ul>
<pre><code class="language-vue">&lt;script setup&gt;
  //
  let url = "http://www.baidu.com"
&lt;/script&gt;

&lt;template&gt;
  &lt;a v-bind:href="url"&gt;go&lt;/a&gt;
  &lt;a :href="url"&gt;go&lt;/a&gt;
&lt;/template&gt;

  &lt;style scoped&gt;

&lt;/style&gt;
</code></pre>
<p>注意：此时如果我们想修改变量的值，属性值并不会跟着修改。可以测试下。因为 v-bind 默认设置还没有响应式特性</p>
<h3 id="444-响应式---ref-"><a class="header" href="#444-响应式---ref-">4.4.4. 响应式 - ref ()</a></h3>
<p>数据的动态变化需要反馈到页面；</p>
<p>Vue 通过 <code>ref ()</code> 和 <code>reactive ()</code> 包装数据，将会生成一个数据的代理对象。vue 内部的 <strong>基于依赖追踪的响应式系统</strong> 就会<strong>追踪</strong>感知<strong>数据变化</strong>，并<strong>触发页面</strong>的重新<strong>渲染</strong>。</p>
<h4 id="4441-使用方式"><a class="header" href="#4441-使用方式">4.4.4.1. 使用方式</a></h4>
<p>使用步骤：</p>
<ol>
<li>使用 <strong>ref ()</strong> 包装<strong>原始类型、对象类型数据</strong>，生成 <strong>代理对象</strong></li>
<li><strong>任何方法、js 代码中</strong>，使用 <code>代理对象.value</code> 的形式读取和修改值</li>
<li><strong>页面组件中</strong>，直接使用 <code>代理对象</code></li>
</ol>
<p>_<strong>注意：</strong>_<em>推荐使用 const（常量） 声明代理对象。代表代理对象不可变，但是内部值变化会被追踪。</em></p>
<pre><code class="language-js">&lt;script setup&gt;
import { ref } from 'vue'

const count = ref (0)

function increment () {
  count.value++
}
&lt;/script&gt;

&lt;template&gt;
  &lt;button @click="increment"&gt;
    {{ count }}
  &lt;/button&gt;
&lt;/template&gt;
</code></pre>
<h4 id="4442-深层响应性"><a class="header" href="#4442-深层响应性">4.4.4.2. 深层响应性</a></h4>
<pre><code class="language-js">import { ref } from 'vue'

const obj = ref ({
  nested: { count: 0 },
  arr: ['foo', 'bar']
})

function mutateDeeply () {
  // 以下都会按照期望工作
  obj.value.nested.count++
  obj.value.arr.push ('baz')
}
</code></pre>
<h3 id="445-响应式---reactive-"><a class="header" href="#445-响应式---reactive-">4.4.5. 响应式 - reactive ()</a></h3>
<p>使用步骤：</p>
<ol>
<li>使用 <strong>reactive ()</strong> 包装<strong>对象类型数据</strong>，生成 <strong>代理对象</strong></li>
<li><strong>任何方法、js 代码中</strong>，使用 <code>代理对象。属性</code> 的形式读取和修改值</li>
<li><strong>页面组件中</strong>，直接使用 <code>代理对象。属性</code></li>
</ol>
<pre><code class="language-vue">import { reactive } from 'vue'

const state = reactive ({ count: 0 })

&lt;button @click="state.count++"&gt;
{{ state.count }}
&lt;/button&gt;
</code></pre>
<p>注意：可以修改 const 变量的内容</p>
<p>基本类型用 ref ()，对象类型用 reactive ()，<code>ref 要用 .value</code>，<code>reactive 直接 .</code> 。页面取值永不变。</p>
<p>也可以 ref 一把梭，大不了天天 .value</p>
<pre><code class="language-vue">&lt;script setup&gt;

import { reactive, ref } from 'vue';

//let name = 'Base2'
let name = "张三"
let age = 18
let car = reactive ({ brand: 'BMW', model: 'X5', price: 400 })
let message = '&lt;p style="color:red"&gt;Hello Vue3&lt;/p&gt;'
function changeName () {
    name = "李四"
    alert ('changeName')
}

let fruits = ['apple', 'banana', 'orange']

let url = ref ('https://www.baidu.com')

function changeUrl () {
    url.value = 'https://www.google.com'
}

function addPrice () {
    car.price += 100
}

&lt;/script&gt;
&lt;template&gt;

    &lt;!-- &lt;a :href="url" :abc="url"&gt; 百度 &lt;/a&gt;&lt;br&gt; --&gt;
    &lt;a v-bind:href="url"&gt;GO {{ url }}&lt;/a&gt;
    &lt;button @click="changeUrl"&gt;Change Url&lt;/button&gt;

    &lt;h1&gt;Hello {{ name }}&lt;/h1&gt;
    &lt;p&gt; {{ age }} component &lt;/p&gt;
    &lt;p&gt; {{ car.brand }} {{ car.model }} &lt;/p&gt;

    &lt;p &gt; 价格：{{ car.price }}&lt;/p&gt;

    &lt;button @click="addPrice"&gt; 加价 &lt;/button&gt;

    &lt;div v-html="message"&gt;&lt;/div&gt;
    &lt;div&gt;{{ message }}&lt;/div&gt;
    &lt;div v-text="message"&gt;&lt;/div&gt;


    &lt;!-- &lt;button @click="changeName"&gt;Change Name&lt;/button&gt; --&gt;
    &lt;button v-on:click.once="changeName"&gt;Change Name&lt;/button&gt;

    &lt;p style="color:blue" v-if="car.price &lt; 1000"&gt; 很便宜 &lt;/p&gt;

    &lt;p style="color: red;" v-else &gt; 太贵了 &lt;/p&gt;

    &lt;ul&gt;
        &lt;li v-for="(fruit, index) in fruits" :key="index"&gt;{{ fruit }}&lt;/li&gt;
    &lt;/ul&gt;

&lt;/template&gt;
&lt;style&gt;&lt;/style&gt;
</code></pre>
<h3 id="446-表单绑定"><a class="header" href="#446-表单绑定">4.4.6. 表单绑定</a></h3>
<pre><code>//2. 指令：v-XXX：
// 基础指令：v-html、v-text
// 事件指令：v-on
// 判断指令：v-if
// 循环指令：v-for
/ 属性绑定：v-bind; 单向绑定，数据 -&gt; 页面
// 表单绑定：v-model; 双向绑定，数据 &lt;--&gt; 页面
</code></pre>
<p>复制如下模板到组件，编写你的代码，实现表单数据绑定。</p>
<pre><code class="language-js">&lt;div style="display: flex;"&gt;
  &lt;div style="border: 1px solid black;width: 300px"&gt;
    &lt;form&gt;
      &lt;h1 &gt; 表单绑定 &lt;/h1&gt;
      &lt;p style="background-color: azure"&gt;&lt;label &gt; 姓名 (文本框)：&lt;/label&gt;&lt;input/&gt;&lt;/p&gt;
      &lt;p style="background-color: azure"&gt;&lt;label &gt; 同意协议 (checkbox)：&lt;/label&gt;
        &lt;input type="checkbox"/&gt;
      &lt;/p&gt;
      &lt;p style="background-color: azure"&gt;
        &lt;label &gt; 兴趣 (多选框)：&lt;/label&gt;&lt;br/&gt;
        &lt;label&gt;&lt;input type="checkbox" value="足球"/&gt; 足球 &lt;/label&gt;
        &lt;label&gt;&lt;input type="checkbox" value="篮球"/&gt; 篮球 &lt;/label&gt;
        &lt;label&gt;&lt;input type="checkbox" value="羽毛球"/&gt; 羽毛球 &lt;/label&gt;
        &lt;label&gt;&lt;input type="checkbox" value="乒乓球"/&gt; 乒乓球 &lt;/label&gt;
      &lt;/p&gt;
      &lt;p style="background-color: azure"&gt;
        &lt;label &gt; 性别 (单选框)：&lt;/label&gt;
        &lt;label&gt;&lt;input type="radio" name="sex" value="男"&gt; 男 &lt;/label&gt;
        &lt;label&gt;&lt;input type="radio" name="sex" value="女"&gt; 女 &lt;/label&gt;
      &lt;/p&gt;
      &lt;p style="background-color: azure"&gt;
        &lt;label &gt; 学历 (单选下拉列表)：&lt;/label&gt;
        &lt;select&gt;
          &lt;option disabled value=""&gt; 选择学历 &lt;/option&gt;
          &lt;option &gt; 小学 &lt;/option&gt;
          &lt;option &gt; 初中 &lt;/option&gt;
          &lt;option &gt; 高中 &lt;/option&gt;
          &lt;option &gt; 大学 &lt;/option&gt;
        &lt;/select&gt;
      &lt;/p&gt;
      &lt;p style="background-color: azure"&gt;
        &lt;label &gt; 课程 (多选下拉列表)：&lt;/label&gt;
        &lt;br/&gt;
        &lt;select multiple&gt;
          &lt;option disabled value=""&gt; 选择课程 &lt;/option&gt;
          &lt;option &gt; 语文 &lt;/option&gt;
          &lt;option &gt; 数学 &lt;/option&gt;
          &lt;option &gt; 英语 &lt;/option&gt;
          &lt;option &gt; 道法 &lt;/option&gt;
        &lt;/select&gt;
      &lt;/p&gt;
    &lt;/form&gt;
  &lt;/div&gt;
  &lt;div style="border: 1px solid blue;width: 200px"&gt;
    &lt;h1 &gt; 结果预览 &lt;/h1&gt;
    &lt;p style="background-color: azure"&gt;&lt;label &gt; 姓名：&lt;/label&gt;&lt;/p&gt;
    &lt;p style="background-color: azure"&gt;&lt;label &gt; 同意协议：&lt;/label&gt;
    &lt;/p&gt;
    &lt;p style="background-color: azure"&gt;
      &lt;label &gt; 兴趣：&lt;/label&gt;
    &lt;/p&gt;
    &lt;p style="background-color: azure"&gt;
      &lt;label &gt; 性别：&lt;/label&gt;
    &lt;/p&gt;
    &lt;p style="background-color: azure"&gt;
      &lt;label &gt; 学历：&lt;/label&gt;
    &lt;/p&gt;
    &lt;p style="background-color: azure"&gt;
      &lt;label &gt; 课程：&lt;/label&gt;
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>完整代码如下所示：</p>
<pre><code class="language-vue">&lt;script setup&gt;

import { reactive, ref } from 'vue';

const data = reactive ({
    name: '',
    agree: false,
    hobby: [],
    sex: '',
    education: '',
    course: []
});

&lt;/script&gt;
&lt;template&gt;

&lt;div style="display: flex;"&gt;
  &lt;div style="border: 1px solid black;width: 300px"&gt;
    &lt;form&gt;
      &lt;h1 &gt; 表单绑定 &lt;/h1&gt;
      &lt;p style="background-color: azure"&gt;&lt;label &gt; 姓名 (文本框)：&lt;/label&gt;&lt;input v-model="data.name"/&gt;&lt;/p&gt;
      &lt;p style="background-color: azure"&gt;&lt;label &gt; 同意协议 (checkbox)：&lt;/label&gt;
        &lt;input type="checkbox" v-model="data.agree"/&gt;
      &lt;/p&gt;
      &lt;p style="background-color: azure"&gt;
        &lt;label &gt; 兴趣 (多选框)：&lt;/label&gt;&lt;br/&gt;
        &lt;label&gt;&lt;input type="checkbox" value="足球" v-model="data.hobby"/&gt; 足球 &lt;/label&gt;
        &lt;label&gt;&lt;input type="checkbox" value="篮球" v-model="data.hobby"/&gt; 篮球 &lt;/label&gt;
        &lt;label&gt;&lt;input type="checkbox" value="乒乓球" v-model="data.hobby"/&gt; 乒乓球 &lt;/label&gt;
      &lt;/p&gt;
      &lt;p style="background-color: azure"&gt;
        &lt;label &gt; 性别 (单选框)：&lt;/label&gt;
        &lt;label&gt;&lt;input type="radio" name="sex" value="男" v-model="data.sex"&gt; 男 &lt;/label&gt;
        &lt;label&gt;&lt;input type="radio" name="sex" value="女" v-model="data.sex"&gt; 女 &lt;/label&gt;
      &lt;/p&gt;
      &lt;p style="background-color: azure"&gt;
        &lt;label &gt; 学历 (单选下拉列表)：&lt;/label&gt;
        &lt;select v-model="data.education"&gt;
          &lt;option disabled value=""&gt; 选择学历 &lt;/option&gt;
          &lt;option &gt; 小学 &lt;/option&gt;
          &lt;option &gt; 初中 &lt;/option&gt;
          &lt;option &gt; 高中 &lt;/option&gt;
          &lt;option &gt; 大学 &lt;/option&gt;
        &lt;/select&gt;
      &lt;/p&gt;
      &lt;p style="background-color: azure"&gt;
        &lt;label &gt; 课程 (多选下拉列表)：&lt;/label&gt;
        &lt;br/&gt;
        &lt;select multiple v-model="data.course"&gt;
          &lt;option disabled value=""&gt; 选择课程 &lt;/option&gt;
          &lt;option &gt; 语文 &lt;/option&gt;
          &lt;option &gt; 数学 &lt;/option&gt;
          &lt;option &gt; 英语 &lt;/option&gt;
          &lt;option &gt; 道法 &lt;/option&gt;
        &lt;/select&gt;
      &lt;/p&gt;
    &lt;/form&gt;
  &lt;/div&gt;
  &lt;div style="border: 1px solid blue;width: 200px"&gt;
    &lt;h1 &gt; 结果预览 &lt;/h1&gt;
    &lt;p style="background-color: azure"&gt;&lt;label &gt; 姓名：{{ data.name }}&lt;/label&gt;&lt;/p&gt;
    &lt;p style="background-color: azure"&gt;&lt;label &gt; 同意协议：{{ data.agree }}&lt;/label&gt;
    &lt;/p&gt;
    &lt;p style="background-color: azure"&gt;
      &lt;label &gt; 兴趣：{{ data.hobby }}&lt;/label&gt;
    &lt;/p&gt;
    &lt;p style="background-color: azure"&gt;
      &lt;label &gt; 性别：{{ data.sex }}&lt;/label&gt;
    &lt;/p&gt;
    &lt;p style="background-color: azure"&gt;
      &lt;label &gt; 学历：{{ data.education }}&lt;/label&gt;
    &lt;/p&gt;
    &lt;p style="background-color: azure"&gt;
      &lt;label &gt; 课程：{{ data.course }}&lt;/label&gt;
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;/template&gt;
&lt;style&gt;&lt;/style&gt;
</code></pre>
<h3 id="447-计算属性---computed"><a class="header" href="#447-计算属性---computed">4.4.7. 计算属性 - computed</a></h3>
<p>计算属性：根据已有数据计算出新数据</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref, computed } from "vue";

// 省略基础代码

const car = ref ({
    brand: "奔驰",
    num: 1,
    price: 100
})

const totalPrice = computed (() =&gt; {
    return car.value.price * car.value.num
})

&lt;/script&gt;

&lt;template&gt;
    &lt;h2 &gt; 基础信息 &lt;/h2&gt;
    &lt;h2 &gt; 品牌：{{ car.brand }}&lt;/h2&gt;
    &lt;h2 &gt; 数量：{{ car.num }}&lt;/h2&gt;
    &lt;h2 &gt; 单价：{{ car.price }}&lt;/h2&gt;
    &lt;h1 &gt; 总价：{{ totalPrice }}&lt;/h1&gt;
    &lt;button @click="car.num++"&gt; 加量 &lt;/button&gt;
    &lt;button @click="car.price++"&gt; 加价 &lt;/button&gt;

&lt;/template&gt;

&lt;style scoped&gt;&lt;/style&gt;
</code></pre>
<h2 id="45-进阶用法"><a class="header" href="#45-进阶用法">4.5. 进阶用法</a></h2>
<h3 id="451-监听---watchwatcheffect"><a class="header" href="#451-监听---watchwatcheffect">4.5.1. 监听 - watch&amp;watchEffect</a></h3>
<pre><code class="language-js">watch (num, (value, oldValue, onCleanup) =&gt; {
  console.log ("newValue：" + value + "；oldValue:" + oldValue)
  onCleanup (() =&gt; {
    console.log ("onCleanup....")
  })
})
</code></pre>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref, computed, watch } from "vue";

// 省略基础代码

const car = ref ({
    brand: "奔驰",
    num: 1,
    price: 100
})

const totalPrice = computed (() =&gt; {
    return car.value.price * car.value.num
})
watch (() =&gt; car.value.num, (value, oldValue) =&gt; {  
    console.log ("value:", value, "oldValue:", oldValue)  
    if (car.value.num &gt; 3) {  
        alert ("数量不能超过 3")  
        car.value.num = 3  
    }  
})
//watch (() =&gt; car.value.num, (value, oldValue) =&gt; {
//     console.log ("value:", value, "oldValue:", oldValue)
//     if (car.num.value &gt; 3) {
//         alert ("数量不能超过 3")
//         car.num.value = 3
//     }
// })

&lt;/script&gt;

&lt;template&gt;
    &lt;h2 &gt; 基础信息 &lt;/h2&gt;
    &lt;h2 &gt; 品牌：{{ car.brand }}&lt;/h2&gt;
    &lt;h2 &gt; 数量：{{ car.num }}&lt;/h2&gt;
    &lt;h2 &gt; 单价：{{ car.price }}&lt;/h2&gt;
    &lt;h1 &gt; 总价：{{ totalPrice }}&lt;/h1&gt;
    &lt;button @click="car.num++"&gt; 加量 &lt;/button&gt;
    &lt;button @click="car.price++"&gt; 加价 &lt;/button&gt;

&lt;/template&gt;

&lt;style scoped&gt;&lt;/style&gt;
</code></pre>
<p>这两个 watch 函数的区别在于监听的属性不同。</p>
<p>第一个 watch 函数中的监听属性是 <code>car.value.num</code>，而第二个 watch 函数中的监听属性是 <code>car.num.value</code>。</p>
<p>在 Vue3 的 Composition API 中，<code>ref</code> 创建的响应式对象可以直接通过 <code>.value</code> 访问其值，而使用 <code>computed</code> 等函数创建的响应式对象则不能直接访问其值，需要通过 <code>.value</code> 来获取。因此，正确的监听属性应该是 <code>car.value.num</code>。</p>
<p>watchEffect 函数监听所有响应式数据</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref, computed, watch, watchEffect } from "vue";

// 省略基础代码

const car = ref ({
    brand: "奔驰",
    num: 1,
    price: 100
})

const totalPrice = computed (() =&gt; {
    return car.value.price * car.value.num
})

watchEffect (() =&gt; {
    if (car.value.num &gt; 3){
        alert ("数量不能超过 3")
        car.value.num = 3
    }
    if (car.value.price &gt; 10000){
        alert ("单价不能超过 10000")
        car.value.price = 10000
    }
})

&lt;/script&gt;

&lt;template&gt;
    &lt;h2 &gt; 基础信息 &lt;/h2&gt;
    &lt;h2 &gt; 品牌：{{ car.brand }}&lt;/h2&gt;
    &lt;h2 &gt; 数量：{{ car.num }}&lt;/h2&gt;
    &lt;h2 &gt; 单价：{{ car.price }}&lt;/h2&gt;
    &lt;h1 &gt; 总价：{{ totalPrice }}&lt;/h1&gt;
    &lt;button @click="car.num++"&gt; 加量 &lt;/button&gt;
    &lt;button @click="car.price++"&gt; 加价 &lt;/button&gt;

&lt;/template&gt;

&lt;style scoped&gt;&lt;/style&gt;
</code></pre>
<h3 id="452-生命周期"><a class="header" href="#452-生命周期">4.5.2. 生命周期</a></h3>
<p>每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模板，挂载实例到 DOM，以及在数据改变时更新 DOM。在此过程中，它也会运行被称为生命周期钩子的函数，让开发者有机会在特定阶段运行自己的代码。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1613913/1712714322676-1b2be398-47b7-4901-ab8d-f5dff873a8ab.png" alt="" /></p>
<p>生命周期整体分为四个阶段，分别是：<code>创建、挂载、更新、销毁</code>，每个阶段都有两个钩子，一前一后。</p>
<p>常用的钩子：</p>
<ul>
<li><strong>onMounted (挂载完毕)</strong></li>
<li><strong>onUpdated (更新完毕)</strong></li>
<li><strong>onBeforeUnmount (卸载之前)</strong></li>
</ul>
<pre><code class="language-vue">&lt;script setup&gt;
import {onBeforeMount, onBeforeUpdate, onMounted, onUpdated, ref} from "vue";
const  count = ref (0)
const btn01 = ref ()

// 生命周期钩子
onBeforeMount (()=&gt;{
  console.log (' 挂载之前 ',count.value,document.getElementById ("btn01"))
})
onMounted (()=&gt;{
  console.log (' 挂载完毕 ',count.value,document.getElementById ("btn01"))
})
onBeforeUpdate (()=&gt;{
  console.log (' 更新之前 ',count.value,btn01.value.innerHTML)
})
onUpdated (()=&gt;{
  console.log (' 更新完毕 ',count.value,btn01.value.innerHTML)
})
&lt;/script&gt;

&lt;template&gt;
  &lt;button ref="btn01" @click="count++"&gt; {{count}} &lt;/button&gt;
&lt;/template&gt;

&lt;style scoped&gt;
&lt;/style&gt;
</code></pre>
<p>输出结果：</p>
<pre><code>baked beans
Life.vue:8 挂载之前 0 null
Life.vue:11 挂载完毕 0 null
Life.vue:14 更新之前 1 0
Life.vue:17 更新完毕 1 1
</code></pre>
<p>更新前内容未变，数据变了</p>
<h3 id="453-组件传值"><a class="header" href="#453-组件传值">4.5.3. 组件传值</a></h3>
<h4 id="4531-父传子---props"><a class="header" href="#4531-父传子---props">4.5.3.1. 父传子 - Props</a></h4>
<p><strong><em>父组件给子组件传递值；</em></strong></p>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref, reactive } from 'vue';
import Son from './Son.vue'

let money = ref (1000)

const data = reactive ({
    money: money,
    name: 'Father',
    age: 30,
    hobby: 'coding'
})

&lt;/script&gt;

&lt;template&gt;
    &lt;div&gt;Father&lt;/div&gt;
    &lt;Son v-bind="data" /&gt;
&lt;/template&gt;

&lt;style scoped&gt;&lt;/style&gt;
</code></pre>
<pre><code class="language-vue">&lt;script setup&gt;

let props = defineProps (['money', "name", "hobby"]);

&lt;/script&gt;

&lt;template&gt;
    &lt;div&gt;Son 组件 &lt;/div&gt;
    &lt;p style="color: aqua;"&gt; 父组件传递的 money 值：{{ props.money }}&lt;/p&gt;
    &lt;p style="color: aqua;"&gt; 父组件传递的 name 值：{{ props.name }}&lt;/p&gt;
    &lt;p style="color: aqua;"&gt; 父组件传递的 hobby 值：{{ props.hobby }}&lt;/p&gt;
&lt;/template&gt;

&lt;style scoped&gt;&lt;/style&gt;
</code></pre>
<p><strong>单向数据流</strong>效果：</p>
<ul>
<li>父组件修改值，子组件发生变化</li>
<li>子组件修改值，父组件不会感知到</li>
</ul>
<pre><code class="language-vue">// 父组件给子组件传递数据：使用属性绑定
&lt;Son :books="data.books" :money="data.money"/&gt;
  
// 子组件定义接受父组件的属性
let props = defineProps ({
  money: {
    type: Number,
    required: true,
    default: 200
  },
  books: Array
});
</code></pre>
<h4 id="4532-子传父---emit"><a class="header" href="#4532-子传父---emit">4.5.3.2. 子传父 - Emit</a></h4>
<p>props 用来父传子，emit 用来子传父</p>
<pre><code class="language-vue">// 子组件定义发生的事件
let emits = defineEmits (['buy']);
function buy (){
  //props.money -= 5;
  emits ('buy',-5);
}

// 父组件感知事件和接受事件值
  &lt;Son :books="data.books" :money="data.money"
       @buy="moneyMinis"/&gt;
</code></pre>
<pre><code class="language-js">&lt;script setup&gt;
import { ref, reactive } from 'vue';
import Son from './Son.vue'

let money = ref (1000)

const data = reactive ({
    money: money,
    name: 'Father',
    age: 30,
    hobby: 'coding'
})

function addMoney () {
    money.value += 100
}

function minusMoney (arg) {
    money.value += arg
}

&lt;/script&gt;

&lt;template&gt;
    &lt;div&gt;Father&lt;/div&gt;
    &lt;div&gt;Money: {{ money }}&lt;/div&gt;
    &lt;button @click="addMoney"&gt;Add Money&lt;/button&gt;
    &lt;div &gt;&lt;Son v-bind="data" style="color: red;" @buy="minusMoney" /&gt;&lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;&lt;/style&gt;
</code></pre>
<pre><code class="language-js">&lt;script setup&gt;

let props = defineProps (['money', "name", "hobby"]);
let emits = defineEmits (['buy']);
function buy () {
    //props.money -= 5;
    emits ('buy', -5);
}


&lt;/script&gt;

&lt;template&gt;
    &lt;div&gt;
        &lt;p style="color: aqua;"&gt; 父组件传递的 money 值：{{ props.money }}&lt;/p&gt;
        &lt;button @click="buy"&gt; 购买 &lt;/button&gt;

        &lt;p style="color: aqua;"&gt; 父组件传递的 name 值：{{ props.name }}&lt;/p&gt;
        &lt;p style="color: aqua;"&gt; 父组件传递的 hobby 值：{{ props.hobby }}&lt;/p&gt;
    &lt;/div&gt;

&lt;/template&gt;

&lt;style scoped&gt;&lt;/style&gt;
</code></pre>
<p>思考：兄弟组件如何传值？</p>
<p>利用父子传值即可</p>
<h3 id="454-插槽---slots"><a class="header" href="#454-插槽---slots">4.5.4. 插槽 - Slots</a></h3>
<p>子组件可以使用插槽接受模板内容。</p>
<h4 id="4541-基本使用"><a class="header" href="#4541-基本使用">4.5.4.1. 基本使用</a></h4>
<pre><code class="language-js">&lt;!-- 组件定义 --&gt;
&lt;button class="fancy-btn"&gt;
  &lt;slot&gt;&lt;/slot&gt; &lt;!-- 插槽出口 --&gt;
&lt;/button&gt;

&lt;!-- 组件使用 --&gt;
&lt;FancyButton&gt;
  Click me! &lt;!-- 插槽内容 --&gt;
&lt;/FancyButton&gt;
</code></pre>
<h4 id="4542-默认内容"><a class="header" href="#4542-默认内容">4.5.4.2. 默认内容</a></h4>
<pre><code class="language-js">&lt;button type="submit"&gt;
  &lt;slot&gt;
    Submit &lt;!-- 默认内容 --&gt;
  &lt;/slot&gt;
&lt;/button&gt;
</code></pre>
<h4 id="4543-具名插槽"><a class="header" href="#4543-具名插槽">4.5.4.3. 具名插槽</a></h4>
<pre><code class="language-js">&lt;div class="container"&gt;
  &lt;header&gt;
    &lt;slot name="header"&gt;&lt;/slot&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;slot name="footer"&gt;&lt;/slot&gt;
  &lt;/footer&gt;
&lt;/div&gt;
</code></pre>
<p>使用： <code>v-slot</code> 可以简写为 <code>#</code></p>
<pre><code class="language-js">&lt;BaseLayout&gt;
  &lt;template v-slot:header&gt;
    &lt;!-- header 插槽的内容放这里 --&gt;
  &lt;/template&gt;
&lt;/BaseLayout&gt;
</code></pre>
<h2 id="46-总结"><a class="header" href="#46-总结">4.6. 总结</a></h2>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1613913/1712737404128-2d94429f-b301-408e-ac3a-88e175b1d45f.png" alt="" /></p>
<p>几个简写：</p>
<ul>
<li><code>v-on</code>=<code>@</code></li>
<li><code>v-bind</code>= <code>:</code></li>
<li><code>v-slot</code>= <code>#</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="vue-router-入门"><a class="header" href="#vue-router-入门">Vue-Router 入门</a></h1>
<ul>
<li><a href="Vue-Router%E9%80%9F%E6%88%90.html#51-%E7%90%86%E8%A7%A3%E8%B7%AF%E7%94%B1">5.1. 理解路由</a></li>
<li><a href="Vue-Router%E9%80%9F%E6%88%90.html#52-%E8%B7%AF%E7%94%B1%E5%85%A5%E9%97%A8">5.2. 路由入门</a>
<ul>
<li><a href="Vue-Router%E9%80%9F%E6%88%90.html#521-%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA">5.2.1. 项目创建</a></li>
<li><a href="Vue-Router%E9%80%9F%E6%88%90.html#522-%E6%95%B4%E5%90%88-vue-router">5.2.2. 整合 vue-router</a></li>
<li><a href="Vue-Router%E9%80%9F%E6%88%90.html#523-%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B">5.2.3. 运行流程</a></li>
<li><a href="Vue-Router%E9%80%9F%E6%88%90.html#524-%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE">5.2.4. 路由配置</a></li>
<li><a href="Vue-Router%E9%80%9F%E6%88%90.html#525-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0">5.2.5. 路径参数</a></li>
</ul>
</li>
<li><a href="Vue-Router%E9%80%9F%E6%88%90.html#53-%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1">5.3. 嵌套路由</a></li>
<li><a href="Vue-Router%E9%80%9F%E6%88%90.html#54-%E7%BC%96%E7%A8%8B%E5%BC%8F">5.4. 编程式</a>
<ul>
<li><a href="Vue-Router%E9%80%9F%E6%88%90.html#541-useroute%E8%B7%AF%E7%94%B1%E6%95%B0%E6%8D%AE">5.4.1. useRoute：路由数据</a></li>
<li><a href="Vue-Router%E9%80%9F%E6%88%90.html#542-userouter%E8%B7%AF%E7%94%B1%E5%99%A8">5.4.2. useRouter：路由器</a></li>
</ul>
</li>
<li><a href="Vue-Router%E9%80%9F%E6%88%90.html#55-%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82">5.5. 路由传参</a>
<ul>
<li><a href="Vue-Router%E9%80%9F%E6%88%90.html#551-params-%E5%8F%82%E6%95%B0">5.5.1. params 参数</a></li>
<li><a href="Vue-Router%E9%80%9F%E6%88%90.html#552-query-%E5%8F%82%E6%95%B0">5.5.2. query 参数</a></li>
</ul>
</li>
<li><a href="Vue-Router%E9%80%9F%E6%88%90.html#56-%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB">5.6. 导航守卫</a></li>
<li><a href="Vue-Router%E9%80%9F%E6%88%90.html#57-%E6%80%BB%E7%BB%93">5.7. 总结</a></li>
</ul>
<h2 id="51-理解路由"><a class="header" href="#51-理解路由">5.1. 理解路由</a></h2>
<p>前端系统根据页面路径，跳转到指定组件，展示出指定效果</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1613913/1709801835501-9cce06a4-3956-4095-8cb3-8a792dd15026.png" alt="" /></p>
<h2 id="52-路由入门"><a class="header" href="#52-路由入门">5.2. 路由入门</a></h2>
<h3 id="521-项目创建"><a class="header" href="#521-项目创建">5.2.1. 项目创建</a></h3>
<pre><code>npm create vite
</code></pre>
<h3 id="522-整合-vue-router"><a class="header" href="#522-整合-vue-router">5.2.2. 整合 vue-router</a></h3>
<p>参照官网即可</p>
<pre><code>npm install vue-router@v4
</code></pre>
<p>index.ts</p>
<pre><code class="language-ts">import { createRouter, createWebHashHistory } from 'vue-router'

const routes = [
  {
    path: '/',
    name: 'Home',
    component: () =&gt; import ('../views/Home.vue')
  },
  {
    path: '/login',
    name: 'Login',
    component: () =&gt; import ('../views/Login.vue')
  },
  {
    path: '/signup',
    name: 'Signup',
    component: () =&gt; import ('../views/Signup.vue')
  }
]

const router = createRouter ({
  history: createWebHashHistory (),
  routes
})

export default router
</code></pre>
<p>App.vue</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { useRouter } from 'vue-router'
&lt;/script&gt;

&lt;template&gt;
  &lt;router-link to="/"&gt;Home&lt;/router-link&gt; 
  &lt;router-link to="/signup"&gt;SignUp&lt;/router-link&gt; 
  &lt;router-link to="/login"&gt;Login&lt;/router-link&gt; 
  &lt;router-view /&gt;
&lt;/template&gt;

&lt;style scoped&gt;

&lt;/style&gt;


</code></pre>
<p>main.ts</p>
<pre><code class="language-ts">import { createApp } from 'vue'
import './style.css'
import App from './App.vue'
import router from './router'

const app = createApp (App)
app.use (router)
app.mount ('#app')


</code></pre>
<h3 id="523-运行流程"><a class="header" href="#523-运行流程">5.2.3. 运行流程</a></h3>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1613913/1709864949734-bc64bfe7-4dec-4886-a0bb-6ebce5bb9369.png?x-oss-process=image%2Fformat%2Cwebp" alt="" /></p>
<h3 id="524-路由配置"><a class="header" href="#524-路由配置">5.2.4. 路由配置</a></h3>
<p>编写一个新的组件，测试路由功能；步骤如下：</p>
<ol>
<li>编写 <code>router/index.js</code> 文件</li>
<li>配置路由表信息</li>
<li>创建路由器并导出</li>
<li>在 <code>main.js</code> 中使用路由</li>
<li>在页面使用 <code>router-link``router-view</code> 完成路由功能</li>
</ol>
<h3 id="525-路径参数"><a class="header" href="#525-路径参数">5.2.5. 路径参数</a></h3>
<p>使用 <code>: 变量名</code> 接受动态参数；这个称为路径参数</p>
<pre><code class="language-js">const routes = [
  // 匹配 /o/3549
  { path: '/o/:orderId' },
  // 匹配 /p/books
  { path: '/p/:productName' },
]
</code></pre>
<p>App.vue</p>
<pre><code class="language-js">&lt;script setup&gt;
import { useRouter } from 'vue-router'
&lt;/script&gt;

&lt;template&gt;
  &lt;router-link to="/"&gt;Home&lt;/router-link&gt; 
  &lt;router-link to="/signup/123"&gt;SignUp&lt;/router-link&gt; 
  &lt;router-link to="/signup/456"&gt;SignUp&lt;/router-link&gt; 
  &lt;router-link to="/login"&gt;Login&lt;/router-link&gt; 
  &lt;router-view /&gt;
&lt;/template&gt;

&lt;style scoped&gt;

&lt;/style&gt;

</code></pre>
<p>index.ts</p>
<pre><code class="language-ts">import { createRouter, createWebHashHistory } from 'vue-router'

const routes = [
  {
    path: '/',
    name: 'Home',
    component: () =&gt; import ('../views/Home.vue')
  },
  {
    path: '/login',
    name: 'Login',
    component: () =&gt; import ('../views/Login.vue')
  },
  {
    path: '/signup/:id',
    name: 'Signup',
    component: () =&gt; import ('../views/Signup.vue')
  }
]

const router = createRouter ({
  history: createWebHashHistory (),
  routes
})

export default router
</code></pre>
<h2 id="53-嵌套路由"><a class="header" href="#53-嵌套路由">5.3. 嵌套路由</a></h2>
<p><img src="https://cdn.nlark.com/yuque/0/2024/gif/1613913/1710212693785-79b447e1-b391-4ef5-8cf5-36637a9442c5.gif" alt="" /></p>
<pre><code class="language-js">const routes = [
  {
    path: '/user/:id',
    component: User,
    children: [
      {
        // 当 /user/:id/profile 匹配成功
        // UserProfile 将被渲染到 User 的 &lt;router-view&gt; 内部
        path: 'profile',
        component: UserProfile,
      },
      {
        // 当 /user/:id/posts 匹配成功
        // UserPosts 将被渲染到 User 的 &lt;router-view&gt; 内部
        path: 'posts',
        component: UserPosts,
      },
    ],
  },
]
</code></pre>
<h2 id="54-编程式"><a class="header" href="#54-编程式">5.4. 编程式</a></h2>
<h3 id="541-useroute路由数据"><a class="header" href="#541-useroute路由数据">5.4.1. useRoute：路由数据</a></h3>
<p>路由传参跳转到指定页面后，页面需要取到传递过来的值，可以使用 <code>useRoute</code> 方法；</p>
<p>拿到当前页路由数据；可以做</p>
<ol>
<li>获取到当前路径</li>
<li>获取到组件名</li>
<li>获取到参数</li>
<li>获取到查询字符串</li>
</ol>
<pre><code class="language-js">import {useRoute} from 'vue-router'
const route = useRoute ()
// 打印 query 参数
console.log (route.query)
// 打印 params 参数
console.log (route.params)
</code></pre>
<h3 id="542-userouter路由器"><a class="header" href="#542-userouter路由器">5.4.2. useRouter：路由器</a></h3>
<p>拿到路由器；可以控制跳转、回退等。</p>
<pre><code class="language-js">import {useRoute, useRouter} from "vue-router";

const router = useRouter ();

// 字符串路径
router.push ('/users/eduardo')

// 带有路径的对象
router.push ({ path: '/users/eduardo' })

// 命名的路由，并加上参数，让路由建立 url
router.push ({ name: 'user', params: { username: 'eduardo' } })

// 带查询参数，结果是 /register?plan=private
router.push ({ path: '/register', query: { plan: 'private' } })

// 带 hash，结果是 /about#team
router.push ({ path: '/about', hash: '#team' })

// 注意： `params` 不能与 `path` 一起使用
router.push ({ path: '/user', params: { username } }) // 错误用法 -&gt; /user
</code></pre>
<h2 id="55-路由传参"><a class="header" href="#55-路由传参">5.5. 路由传参</a></h2>
<h3 id="551-params-参数"><a class="header" href="#551-params-参数">5.5.1. params 参数</a></h3>
<pre><code class="language-js">&lt;!-- 跳转并携带 params 参数（to 的字符串写法） --&gt;
&lt;RouterLink :to="`/news/detail/001 / 新闻 001 / 内容 001`"&gt;{{news.title}}&lt;/RouterLink&gt;

&lt;!-- 跳转并携带 params 参数（to 的对象写法） --&gt;
&lt;RouterLink 
  :to="{
        name:'xiang', // 用 name 跳转，params 情况下，不可用 path
        params:{
          id:news.id,
          title:news.title,
          content:news.title
        }
  }"
  &gt;
  {{news.title}}
&lt;/RouterLink&gt;
</code></pre>
<h3 id="552-query-参数"><a class="header" href="#552-query-参数">5.5.2. query 参数</a></h3>
<pre><code class="language-js">&lt;!-- 跳转并携带 query 参数（to 的字符串写法） --&gt;
&lt;router-link to="/news/detail?a=1&amp;b=2&amp;content = 欢迎你"&gt;
	跳转
&lt;/router-link&gt;
				
&lt;!-- 跳转并携带 query 参数（to 的对象写法） --&gt;
&lt;RouterLink 
  :to="{
    //name:'xiang', // 用 name 也可以跳转
    path:'/news/detail',
    query:{
      id:news.id,
      title:news.title,
      content:news.content
    }
  }"
&gt;
  {{news.title}}
&lt;/RouterLink&gt;
</code></pre>
<h2 id="56-导航守卫"><a class="header" href="#56-导航守卫">5.6. 导航守卫</a></h2>
<p>我们只演示全局前置守卫。后置钩子等内容参照官方文档</p>
<pre><code class="language-js">import {createRouter, createWebHistory} from 'vue-router'
import HomeView from '../views/HomeView.vue'

const router = createRouter ({
    history: createWebHistory (import.meta.env.BASE_URL),
    routes: [
        {
            path: '/',
            name: 'home',
            component: HomeView
        },
        {
            path: '/about',
            name: 'about',
            //route level code-splitting
            //this generates a separate chunk (About.[hash].js) for this route
            //which is lazy-loaded when the route is visited.
            component: () =&gt; import ('../views/AboutView.vue')
        },
        {
            path: '/user/:name',
            name: 'User',
            component: () =&gt; import ('@/views/user/UserInfo.vue'),
            children: [
                {
                    path: 'profile',
                    component: () =&gt; import ('@/views/user/Profile.vue')
                },
                {
                    path: 'posts',
                    component: () =&gt; import ('@/views/user/Posts.vue')
                }
            ]
        }
    ]
})

router.beforeEach (async (to, from) =&gt; {
    console.log ("守卫：to：", to)
    console.log ("守卫：from：", from)
    if (to.fullPath === '/about') {
       return "/"
    }
})

export default router
</code></pre>
<h2 id="57-总结"><a class="header" href="#57-总结">5.7. 总结</a></h2>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1613913/1712842500600-cd5098c4-2c44-4932-867b-1db92c5aa2bb.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="axios-速成"><a class="header" href="#axios-速成">Axios 速成</a></h1>
<ul>
<li><a href="Axios%E9%80%9F%E6%88%90.html#61-%E7%AE%80%E4%BB%8B">6.1. 简介</a></li>
<li><a href="Axios%E9%80%9F%E6%88%90.html#62-%E8%AF%B7%E6%B1%82">6.2. 请求</a>
<ul>
<li><a href="Axios%E9%80%9F%E6%88%90.html#621-get-%E8%AF%B7%E6%B1%82">6.2.1. get 请求</a></li>
<li><a href="Axios%E9%80%9F%E6%88%90.html#622-post-%E8%AF%B7%E6%B1%82">6.2.2. post 请求</a></li>
</ul>
</li>
<li><a href="Axios%E9%80%9F%E6%88%90.html#63-%E5%93%8D%E5%BA%94">6.3. 响应</a></li>
<li><a href="Axios%E9%80%9F%E6%88%90.html#64-%E9%85%8D%E7%BD%AE">6.4. 配置</a></li>
<li><a href="Axios%E9%80%9F%E6%88%90.html#65-%E6%8B%A6%E6%88%AA%E5%99%A8">6.5. 拦截器</a></li>
<li><a href="Axios%E9%80%9F%E6%88%90.html#%E5%AE%9E%E6%88%98">实战</a></li>
</ul>
<h2 id="61-简介"><a class="header" href="#61-简介">6.1. 简介</a></h2>
<p>Axios 是一个基于 promise 的网络请求库，可以用于浏览器和 node.js</p>
<pre><code>npm install axios
</code></pre>
<pre><code class="language-js">import axios from "axios"
axios.get ('/user')
     .then (res =&gt; console.log (resp.data))
</code></pre>
<p>API 测试服务器： <a href="http://43.139.239.29/">http://43.139.239.29/</a></p>
<h2 id="62-请求"><a class="header" href="#62-请求">6.2. 请求</a></h2>
<h3 id="621-get-请求"><a class="header" href="#621-get-请求">6.2.1. get 请求</a></h3>
<pre><code class="language-js">// 向给定 ID 的用户发起请求
axios.get ('/user?ID=12345')
  .then (function (response) {
    // 处理成功情况
    console.log (response);
  })
  .catch (function (error) {
    // 处理错误情况
    console.log (error);
  })
  .finally (function () {
    // 总是会执行
  });
</code></pre>
<p>携带请求参数</p>
<pre><code class="language-js">// 上述请求也可以按以下方式完成（可选）
axios.get ('/user', {
    params: {
      ID: 12345
    }
  })
  .then (function (response) {
    console.log (response);
  })
  .catch (function (error) {
    console.log (error);
  })
  .finally (function () {
    // 总是会执行
  });  
</code></pre>
<h3 id="622-post-请求"><a class="header" href="#622-post-请求">6.2.2. post 请求</a></h3>
<p>默认 <code>post 请求体</code> 中的数据将会以 <code>json</code> 方式提交</p>
<pre><code class="language-js">axios.post ('/user', {
  firstName: 'Fred',
  lastName: 'Flintstone'
})
.then (function (response) {
  console.log (response);
})
.catch (function (error) {
  console.log (error);
});
</code></pre>
<h2 id="63-响应"><a class="header" href="#63-响应">6.3. 响应</a></h2>
<p>响应的数据结构如下：</p>
<pre><code class="language-js">{
  // `data` 由服务器提供的响应
  data: {},

  // `status` 来自服务器响应的 HTTP 状态码
  status: 200,
  
  // `statusText` 来自服务器响应的 HTTP 状态信息
  statusText: 'OK',

  // `headers` 是服务器响应头
  // 所有的 header 名称都是小写，而且可以使用方括号语法访问
  // 例如: `response.headers ['content-type']`
  headers: {},

  // `config` 是 `axios` 请求的配置信息
  config: {},

  // `request` 是生成此响应的请求
  // 在 node.js 中它是最后一个 ClientRequest 实例 (in redirects)，
  // 在浏览器中则是 XMLHttpRequest 实例
  request: {}
}
</code></pre>
<h2 id="64-配置"><a class="header" href="#64-配置">6.4. 配置</a></h2>
<pre><code class="language-js">const instance = axios.create ({
  baseURL: 'https://some-domain.com/api/',
  timeout: 1000,
  headers: {'X-Custom-Header': 'foobar'}
});

// 可用的配置项如下：
{
  // `url` 是用于请求的服务器 URL
  url: '/user',

  // `method` 是创建请求时使用的方法
  method: 'get', // 默认值

  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。
  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL
  baseURL: 'https://some-domain.com/api/',

  // `transformRequest` 允许在向服务器发送前，修改请求数据
  // 它只能用于 'PUT', 'POST' 和 'PATCH' 这几个请求方法
  // 数组中最后一个函数必须返回一个字符串， 一个 Buffer 实例，ArrayBuffer，FormData，或 Stream
  // 你可以修改请求头。
  transformRequest: [function (data, headers) {
    // 对发送的 data 进行任意转换处理

    return data;
  }],

  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据
  transformResponse: [function (data) {
    // 对接收的 data 进行任意转换处理

    return data;
  }],

  // 自定义请求头
  headers: {'X-Requested-With': 'XMLHttpRequest'},

  // `params` 是与请求一起发送的 URL 参数
  // 必须是一个简单对象或 URLSearchParams 对象
  params: {
    ID: 12345
  },

  // `paramsSerializer` 是可选方法，主要用于序列化 `params`
  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)
  paramsSerializer: function (params) {
    return Qs.stringify (params, {arrayFormat: 'brackets'})
  },

  // `data` 是作为请求体被发送的数据
  // 仅适用 'PUT', 'POST', 'DELETE 和 'PATCH' 请求方法
  // 在没有设置 `transformRequest` 时，则必须是以下类型之一:
  //- string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams
  //- 浏览器专属: FormData, File, Blob
  //- Node 专属: Stream, Buffer
  data: {
    firstName: 'Fred'
  },
  
  // 发送请求体数据的可选语法
  // 请求方式 post
  // 只有 value 会被发送，key 则不会
  data: 'Country=Brasil&amp;City=Belo Horizonte',

  // `timeout` 指定请求超时的毫秒数。
  // 如果请求时间超过 `timeout` 的值，则请求会被中断
  timeout: 1000, // 默认值是 `0` (永不超时)

  // `withCredentials` 表示跨域请求时是否需要使用凭证
  withCredentials: false, //default

  // `adapter` 允许自定义处理请求，这使测试更加容易。
  // 返回一个 promise 并提供一个有效的响应 （参见 lib/adapters/README.md）。
  adapter: function (config) {
    /* ... */
  },

  // `auth` HTTP Basic Auth
  auth: {
    username: 'janedoe',
    password: 's00pers3cret'
  },

  // `responseType` 表示浏览器将要响应的数据类型
  // 选项包括: 'arraybuffer', 'document', 'json', 'text', 'stream'
  // 浏览器专属：'blob'
  responseType: 'json', // 默认值

  // `responseEncoding` 表示用于解码响应的编码 (Node.js 专属)
  // 注意：忽略 `responseType` 的值为'stream'，或者是客户端请求
  // Note: Ignored for `responseType` of'stream' or client-side requests
  responseEncoding: 'utf8', // 默认值

  // `xsrfCookieName` 是 xsrf token 的值，被用作 cookie 的名称
  xsrfCookieName: 'XSRF-TOKEN', // 默认值

  // `xsrfHeaderName` 是带有 xsrf token 值的 http 请求头名称
  xsrfHeaderName: 'X-XSRF-TOKEN', // 默认值

  // `onUploadProgress` 允许为上传处理进度事件
  // 浏览器专属
  onUploadProgress: function (progressEvent) {
    // 处理原生进度事件
  },

  // `onDownloadProgress` 允许为下载处理进度事件
  // 浏览器专属
  onDownloadProgress: function (progressEvent) {
    // 处理原生进度事件
  },

  // `maxContentLength` 定义了 node.js 中允许的 HTTP 响应内容的最大字节数
  maxContentLength: 2000,

  // `maxBodyLength`（仅 Node）定义允许的 http 请求内容的最大字节数
  maxBodyLength: 2000,

  // `validateStatus` 定义了对于给定的 HTTP 状态码是 resolve 还是 reject promise。
  // 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，
  // 则 promise 将会 resolved，否则是 rejected。
  validateStatus: function (status) {
    return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认值
  },

  // `maxRedirects` 定义了在 node.js 中要遵循的最大重定向数。
  // 如果设置为 0，则不会进行重定向
  maxRedirects: 5, // 默认值

  // `socketPath` 定义了在 node.js 中使用的 UNIX 套接字。
  //e.g. '/var/run/docker.sock' 发送请求到 docker 守护进程。
  // 只能指定 `socketPath` 或 `proxy` 。
  // 若都指定，这使用 `socketPath` 。
  socketPath: null, //default

  // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http
  //and https requests, respectively, in node.js. This allows options to be added like
  // `keepAlive` that are not enabled by default.
  httpAgent: new http.Agent ({ keepAlive: true }),
  httpsAgent: new https.Agent ({ keepAlive: true }),

  // `proxy` 定义了代理服务器的主机名，端口和协议。
  // 您可以使用常规的 `http_proxy` 和 `https_proxy` 环境变量。
  // 使用 `false` 可以禁用代理功能，同时环境变量也会被忽略。
  // `auth` 表示应使用 HTTP Basic auth 连接到代理，并且提供凭据。
  // 这将设置一个 `Proxy-Authorization` 请求头，它会覆盖 `headers` 中已存在的自定义 `Proxy-Authorization` 请求头。
  // 如果代理服务器使用 HTTPS，则必须设置 protocol 为 `https`
  proxy: {
    protocol: 'https',
    host: '127.0.0.1',
    port: 9000,
    auth: {
      username: 'mikeymike',
      password: 'rapunz3l'
    }
  },

  //see https://axios-http.com/zh/docs/cancellation
  cancelToken: new CancelToken (function (cancel) {
  }),

  // `decompress` indicates whether or not the response body should be decompressed 
  //automatically. If set to `true` will also remove the 'content-encoding' header 
  //from the responses objects of all decompressed responses
  //- Node only (XHR cannot turn off decompression)
  decompress: true // 默认值

}
</code></pre>
<h2 id="65-拦截器"><a class="header" href="#65-拦截器">6.5. 拦截器</a></h2>
<pre><code class="language-js">// 添加请求拦截器
axios.interceptors.request.use (function (config) {
    // 在发送请求之前做些什么
    return config;
  }, function (error) {
    // 对请求错误做些什么
    return Promise.reject (error);
  });

// 添加响应拦截器
axios.interceptors.response.use (function (response) {
    // 2xx 范围内的状态码都会触发该函数。
    // 对响应数据做点什么
    return response;
  }, function (error) {
    // 超出 2xx 范围的状态码都会触发该函数。
    // 对响应错误做点什么
    return Promise.reject (error);
  });
</code></pre>
<h2 id="实战"><a class="header" href="#实战">实战</a></h2>
<p>单文件写法</p>
<pre><code class="language-js">&lt;script setup&gt;
import axios from 'axios'

const instance = axios.create ({
  baseURL: 'http://43.139.239.29',
  timeout: 1000,
  headers: {
    'Content-Type': 'application/json'
  }
})

function getInfo () {
  //const url = 'https://jsonplaceholder.typicode.com/todos/1'
  instance.get ('/get')
    .then (response =&gt; {
      console.log (response.data)
    })
    .catch (error =&gt; {
      console.log (error)
    }
    )
}
function getInfoWithParam () {
  //const url = 'https://jsonplaceholder.typicode.com/todos/1'
  instance.get ('/get', {
    params: {
      id: 1,
      name: 'John'
    }
  })
    .then (response =&gt; {
      console.log (response.data)
    })
    .catch (error =&gt; {
      console.log (error)
    }
    )
}

function postInfo () {
  //const url = 'https://jsonplaceholder.typicode.com/todos/1'
  instance.post ('/post')
    .then (response =&gt; {
      console.log (response)
    })
    .catch (error =&gt; {
      console.log (error)
    }
    )
}
function postInfoWithParam () {
  //const url = 'https://jsonplaceholder.typicode.com/todos/1'
  instance.post ('/post', {
    id: 1,
    name: 'John'
  })
    .then (response =&gt; {
      console.log (response)
    })
    .catch (error =&gt; {
      console.log (error)
    }
    )
}

&lt;/script&gt;

&lt;template&gt;
  &lt;button @click="getInfo ()"&gt;Get Info&lt;/button&gt;
  &lt;button @click="getInfoWithParam ()"&gt;Get Info With Param&lt;/button&gt;
  &lt;button @click="postInfo ()"&gt;Post Info&lt;/button&gt;
  &lt;button @click="postInfoWithParam ()"&gt;Post Info With Param&lt;/button&gt;
&lt;/template&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<p>多文件，添加拦截器</p>
<pre><code class="language-js">&lt;script setup&gt;

import instance from './utils/http/axiosInstance';
import { message } from 'ant-design-vue';
function getInfo () {
  //const url = 'https://jsonplaceholder.typicode.com/todos/1'
  instance.get ('/get')
    .then (response =&gt; {
      console.log (response.data)
    })
    .catch (error =&gt; {
      //console.log (error)
    }
    )
}
function getInfoWithParam () {
  //const url = 'https://jsonplaceholder.typicode.com/todos/1'
  instance.get ('/get', {
    params: {
      id: 1,
      name: 'John'
    }
  })
    .then (response =&gt; {
      console.log (response.data)
    })
    .catch (error =&gt; {
      //console.log (error)
    }
    )
}

function postInfo () {
  //const url = 'https://jsonplaceholder.typicode.com/todos/1'
  instance.post ('/post')
    .then (response =&gt; {
      console.log (response)
    })
    .catch (error =&gt; {
      //console.log (error)
    }
    )
}
function postInfoWithParam () {
  //const url = 'https://jsonplaceholder.typicode.com/todos/1'
  instance.post ('/post', {
    id: 1,
    name: 'John'
  })
    .then (response =&gt; {
      console.log (response)
    })
    .catch (error =&gt; {
      //console.log (error)
    }
    )
}

function delay2s () {
  instance.get ('/delay/2')
    .then (response =&gt; {
      console.log (response)
    })
    .catch (error =&gt; {
      //console.log (error)
      //message.error (error.message)
    }
  )
}

&lt;/script&gt;

&lt;template&gt;
  &lt;button @click="getInfo ()"&gt;Get Info&lt;/button&gt;
  &lt;button @click="getInfoWithParam ()"&gt;Get Info With Param&lt;/button&gt;
  &lt;button @click="postInfo ()"&gt;Post Info&lt;/button&gt;
  &lt;button @click="postInfoWithParam ()"&gt;Post Info With Param&lt;/button&gt;
  &lt;button @click="delay2s ()"&gt;Delay 2s&lt;/button&gt;
&lt;/template&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<pre><code class="language-js">import axios from 'axios'
import { message } from 'ant-design-vue';
const instance = axios.create ({
  baseURL: 'http://43.139.239.29',
  timeout: 1000,
  headers: {
    'Content-Type': 'application/json'
  }
})

// 添加请求拦截器
instance.interceptors.request.use (function (config) {
    // 在发送请求之前做些什么
    return config;
  }, function (error) {
    // 对请求错误做些什么
    console.log (error);
    message.error (' 请求超时，请检查网络连接或联系管理员！');
    return Promise.reject (error);
  });

// 添加响应拦截器
instance.interceptors.response.use (function (response) {
    // 2xx 范围内的状态码都会触发该函数。
    // 对响应数据做点什么
    return response;
  }, function (error) {
    // 超出 2xx 范围的状态码都会触发该函数。
    // 对响应错误做点什么
    console.log (error);
    message.error (' 请求失败，请检查网络连接或联系管理员！');
    return Promise.reject (error);
  });

export default instance
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="pinia-入门"><a class="header" href="#pinia-入门">Pinia 入门</a></h1>
<ul>
<li><a href="Pinia%E5%85%A5%E9%97%A8.html#71-%E6%A0%B8%E5%BF%83">7.1. 核心</a></li>
<li><a href="Pinia%E5%85%A5%E9%97%A8.html#72-%E6%95%B4%E5%90%88">7.2. 整合</a></li>
<li><a href="Pinia%E5%85%A5%E9%97%A8.html#73-%E6%A1%88%E4%BE%8B">7.3. 案例</a></li>
<li><a href="Pinia%E5%85%A5%E9%97%A8.html#74-setup-%E5%86%99%E6%B3%95">7.4. setup 写法</a></li>
</ul>
<h2 id="71-核心"><a class="header" href="#71-核心">7.1. 核心</a></h2>
<p><strong>Pinia</strong> 是 Vue 的<strong>存储库</strong>，它允许您<strong>跨组件 / 页面共享状态</strong>。</p>
<p>Pinia 三个核心概念：</p>
<ul>
<li>State：表示 Pinia Store 内部保存的数据（data）</li>
<li>Getter：可以认为是 Store 里面数据的计算属性（computed）</li>
<li>Actions：是暴露修改数据的几种方式。</li>
</ul>
<p><strong>虽然外部也可以直接读写 Pinia Store 中保存的 data，但是我们建议使用 Actions 暴露的方法操作数据更加安全</strong>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1613913/1712928014360-66fb4f45-471c-443b-be5d-6ca43778f7fe.png" alt="" /></p>
<h2 id="72-整合"><a class="header" href="#72-整合">7.2. 整合</a></h2>
<pre><code>npm install pinia
</code></pre>
<p>main.js</p>
<pre><code class="language-js">import { createApp } from 'vue'
import './style.css'
import App from './App.vue'
import {createPinia} from 'pinia'

const pinia = createPinia ();

createApp (App)
    .use (pinia)
    .mount ('#app')
</code></pre>
<h2 id="73-案例"><a class="header" href="#73-案例">7.3. 案例</a></h2>
<p><code>stores/money.js</code> 编写内容；</p>
<pre><code class="language-js">import {defineStore} from 'pinia'

// 定义一个 money 存储单元
export const useMoneyStore = defineStore ('money', {
    state: () =&gt; ({money: 100}),
    getters: {
        rmb: (state) =&gt; state.money,
        usd: (state) =&gt; state.money * 0.14,
        eur: (state) =&gt; state.money * 0.13,
    },
    actions: {
        win (arg) {
            this.money+=arg;
        },
        pay (arg){
            this.money -= arg;
        }
    },
});
</code></pre>
<p>App.vue</p>
<pre><code class="language-vue">&lt;script setup&gt;
import Wallet from "./components/Wallet.vue";
import Game from "./components/Game.vue";
&lt;/script&gt;

&lt;template&gt;
  &lt;Wallet&gt;&lt;/Wallet&gt;
  &lt;Game/&gt;

&lt;/template&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre>
<p>Wallet.vue</p>
<pre><code class="language-vue">&lt;script setup&gt;
import  {useMoneyStore} from '../stores/money.js'
let moneyStore = useMoneyStore ();

&lt;/script&gt;

&lt;template&gt;
&lt;div&gt;
  &lt;h2&gt;￥：{{moneyStore.rmb}}&lt;/h2&gt;
  &lt;h2&gt;$：{{moneyStore.usd}}&lt;/h2&gt;
  &lt;h2&gt;€：{{moneyStore.eur}}&lt;/h2&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;
div {
  background-color: #f9f9f9;
}
&lt;/style&gt;
</code></pre>
<p>Game.vue</p>
<pre><code class="language-vue">&lt;script setup&gt;
import  {useMoneyStore} from '../stores/money.js'

let moneyStore = useMoneyStore ();
function guaguale (){
  moneyStore.win (100);
}

function bangbang (){
  moneyStore.pay (5)
}
&lt;/script&gt;

&lt;template&gt;
  &lt;button @click="guaguale"&gt; 刮刮乐 &lt;/button&gt;
  &lt;button @click="bangbang"&gt; 买棒棒糖 &lt;/button&gt;
&lt;/template&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre>
<h2 id="74-setup-写法"><a class="header" href="#74-setup-写法">7.4. setup 写法</a></h2>
<pre><code class="language-js">export const useMoneyStore = defineStore ('money', () =&gt; {
    const salary = ref (1000); //ref () 就是 state 属性
    const dollar = computed (() =&gt; salary.value * 0.14); //  computed () 就是 getters
    const eur = computed (() =&gt; salary.value * 0.13); //computed () 就是 getters

    //function () 就是 actions
    const pay = () =&gt; {
        salary.value -= 100;
    }

    const win = () =&gt; {
        salary.value += 1000;
    }

    // 重要：返回可用对象
    return {salary,dollar,eur,pay,win}
})
</code></pre>
<p>完整代码：</p>
<pre><code class="language-js">import {defineStore} from 'pinia'

// 定义一个 money 存储单元
//export const useMoneyStore = defineStore ('money', {
//     state: () =&gt; ({money: 100}),
//     getters: {
//         rmb: (state) =&gt; state.money,
//         usd: (state) =&gt; state.money * 0.14,
//         eur: (state) =&gt; state.money * 0.13,
//     },
//     actions: {
//         win (arg) {
//             this.money+=arg;
//         },
//         pay (arg){
//             this.money -= arg;
//         }
//     },
// });
export const useMoneyStore = defineStore ('money',() =&gt; {
    const money = ref (100);
    const rmb = computed (() =&gt; money.value);
    const usd = computed (() =&gt; money.value * 0.14);
    const eur = computed (() =&gt; money.value * 0.13);
    const win = (arg) =&gt; {
        money.value += arg;
    };
    const pay = (arg) =&gt; {
        money.value -= arg;
    };
    return {
        money,
        rmb,
        usd,
        eur,
        win,
        pay
    };
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="ant-design-vue"><a class="header" href="#ant-design-vue">Ant Design Vue</a></h1>
<ul>
<li><a href="AntDesignVue%E5%85%A5%E9%97%A8.html#%E5%AE%98%E7%BD%91">官网</a></li>
<li><a href="AntDesignVue%E5%85%A5%E9%97%A8.html#91-%E6%95%B4%E5%90%88">9.1. 整合</a></li>
<li><a href="AntDesignVue%E5%85%A5%E9%97%A8.html#92-%E5%B8%83%E5%B1%80">9.2. 布局</a></li>
<li><a href="AntDesignVue%E5%85%A5%E9%97%A8.html#93-%E7%BB%84%E4%BB%B6">9.3. 组件</a></li>
</ul>
<h2 id="官网"><a class="header" href="#官网">官网</a></h2>
<p>官网：<a href="https://www.antdv.com/">https://www.antdv.com/</a></p>
<p>使用 <code>npm create vue@latest</code> 创建出项目脚手架，然后整合 <code>ant design vue</code></p>
<h2 id="91-整合"><a class="header" href="#91-整合">9.1. 整合</a></h2>
<p>安装依赖</p>
<pre><code>npm i --save ant-design-vue@4.x
</code></pre>
<p>全局注册： 编写 <code>main.js</code></p>
<pre><code class="language-js">import { createApp } from 'vue';
import Antd from 'ant-design-vue';
import App from './App';
import 'ant-design-vue/dist/reset.css';

const app = createApp (App);

app.use (Antd).mount ('#app');
</code></pre>
<p>使用图标需要执行 <code>npm install --save @ant-design/icons-vue</code></p>
<pre><code class="language-js">&lt;template&gt;
  &lt;a-menu v-model:selectedKeys="current" mode="horizontal" :items="items" /&gt;
&lt;/template&gt;
&lt;script setup&gt;
import { h, ref } from 'vue';
import { MailOutlined, AppstoreOutlined, SettingOutlined } from '@ant-design/icons-vue';
const current = ref (['mail']);
const items = ref ([
  {
    key: 'mail',
    icon: () =&gt; h (MailOutlined),
    label: 'Navigation One',
    title: 'Navigation One',
  },
  {
    key: 'app',
    icon: () =&gt; h (AppstoreOutlined),
    label: 'Navigation Two',
    title: 'Navigation Two',
  },
  {
    key: 'sub1',
    icon: () =&gt; h (SettingOutlined),
    label: 'Navigation Three - Submenu',
    title: 'Navigation Three - Submenu',
    children: [
      {
        type: 'group',
        label: 'Item 1',
        children: [
          {
            label: 'Option 1',
            key: 'setting:1',
          },
          {
            label: 'Option 2',
            key: 'setting:2',
          },
        ],
      },
      {
        type: 'group',
        label: 'Item 2',
        children: [
          {
            label: 'Option 3',
            key: 'setting:3',
          },
          {
            label: 'Option 4',
            key: 'setting:4',
          },
        ],
      },
    ],
  },
  {
    key: 'alipay',
    label: h (
      'a',
      {
        href: 'https://antdv.com',
        target: '_blank',
      },
      'Navigation Four - Link',
    ),
    title: 'Navigation Four - Link',
  },
]);
&lt;/script&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<h2 id="92-布局"><a class="header" href="#92-布局">9.2. 布局</a></h2>
<ul>
<li>
<p><strong>Layout：布局容器</strong>，其下可<strong>嵌套 Header Sider Content Footer 或 Layout 本身</strong>，可以<strong>放在任何父容器中</strong>。</p>
</li>
<li>
<p>Header：顶部布局，<strong>自带默认样式</strong>，其下可嵌套任何元素，只能放在 Layout 中。</p>
</li>
<li>
<p>Sider：侧边栏，<strong>自带默认样式及基本功能</strong>，其下可嵌套任何元素，只能放在 Layout 中。</p>
</li>
<li>
<p>Content：内容部分，<strong>自带默认样式</strong>，其下可嵌套任何元素，只能放在 Layout 中。</p>
</li>
<li>
<p>Footer：底部布局，<strong>自带默认样式</strong>，其下可嵌套任何元素，只能放在 Layout 中。</p>
</li>
</ul>
<p>一个典型的后台管理系统布局</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1613913/1710830318280-23e4cd6a-a516-4ac2-9711-3076987b3eaa.png" alt="" /></p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;a-layout id="components-layout-demo" style="height: 100vh"&gt;
    &lt;a-layout-sider v-model:collapsed="collapsed" :trigger="null" collapsible&gt;
      &lt;div class="logo" /&gt;
      &lt;a-menu v-model:selectedKeys="selectedKeys" theme="dark" mode="inline"&gt;
        &lt;a-menu-item key="1"&gt;
          &lt;user-outlined /&gt;
          &lt;span&gt;nav 1&lt;/span&gt;
        &lt;/a-menu-item&gt;
        &lt;a-menu-item key="2"&gt;
          &lt;video-camera-outlined /&gt;
          &lt;span&gt;nav 2&lt;/span&gt;
        &lt;/a-menu-item&gt;
        &lt;a-menu-item key="3"&gt;
          &lt;upload-outlined /&gt;
          &lt;span&gt;nav 3&lt;/span&gt;
        &lt;/a-menu-item&gt;
      &lt;/a-menu&gt;
    &lt;/a-layout-sider&gt;
    &lt;a-layout&gt;
      &lt;a-layout-header style="background: #fff; padding: 0"&gt;
        &lt;menu-unfold-outlined
            v-if="collapsed"
            class="trigger"
            @click="() =&gt; (collapsed = !collapsed)"
        /&gt;
        &lt;menu-fold-outlined v-else class="trigger" @click="() =&gt; (collapsed = !collapsed)" /&gt;
      &lt;/a-layout-header&gt;
      &lt;a-layout-content
          :style="{ margin: '24px 16px', padding: '24px', background: '#fff', minHeight: '280px' }"
      &gt;
        Content
      &lt;/a-layout-content&gt;
    &lt;/a-layout&gt;
  &lt;/a-layout&gt;
&lt;/template&gt;
&lt;script setup&gt;
import { ref } from 'vue';
const selectedKeys = ref (['1']);
const collapsed = ref (false);
&lt;/script&gt;
&lt;style&gt;
#components-layout-demo .trigger {
  font-size: 18px;
  line-height: 64px;
  padding: 0 24px;
  cursor: pointer;
  transition: color 0.3s;
}

#components-layout-demo .trigger:hover {
  color: #1890ff;
}

#components-layout-demo .logo {
  height: 32px;
  background: rgba (255, 255, 255, 0.3);
  margin: 16px;
}

.site-layout .site-layout-background {
  background: #fff;
}
&lt;/style&gt;
</code></pre>
<h2 id="93-组件"><a class="header" href="#93-组件">9.3. 组件</a></h2>
<p>参照官网使用即可</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
